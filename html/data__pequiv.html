<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Chris Hughes. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Chris Hughes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import data.equiv.basic data.set.lattice tactic.tauto</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tauto.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  universes u v w x</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  /-- A `pequiv` is a partial equivalence, a representation of a bijection between a subset</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12    of `α` and a subset of `β` -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  structure pequiv (α : Type u) (β : Type v) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  (to_fun : α → option β)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → option.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  (inv_fun : β → option α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  (inv : ∀ (a : α) (b : β), a ∈ inv_fun b ↔ b ∈ to_fun a)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ (a : α) (b : β), iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (inv_fun b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (to_fun a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → option.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  infixr ` ≃. `:25 := pequiv</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  namespace pequiv</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  variables {α : Type u} {β : Type v} {γ : Type w} {δ : Type x}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  open function option</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  instance : has_coe_to_fun (α ≃. β) := ⟨_, to_fun⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_coe_to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pequiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Sort u → Sort (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → α → option.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  @[simp] lemma coe_mk_apply (f₁ : α → option β) (f₂ : β → option α) (h) (x : α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27    (pequiv.mk f₁ f₂ h : α → option β) x = f₁ x := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pequiv.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} (to_fun : α → option.{v} β) (inv_fun : β → option.{u} α), (∀ (a : α) (b : β), iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (inv_fun b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (to_fun a))) → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → option.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a : α) (b : β), iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → option.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  @[ext] lemma ext : ∀ {f g : α ≃. β} (h : ∀ x, f x = g x), f = g</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='∀ {f g : pequiv.{u v} α β}, (∀ (x : α), @eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g x)) → @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='lemmas usable by `ext` tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  | ⟨f₁, f₂, hf⟩ ⟨g₁, g₂, hg⟩ h :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='g₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → option.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α → option.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ (x : α), @eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) (@pequiv.mk.{u v} α β f₁ f₂ hf) x) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) (@pequiv.mk.{u v} α β g₁ g₂ hg) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  have h : f₁ = g₁, from funext h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/funext.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u} {β : α → Type v} {f₁ f₂ : Π (x : α), β x}, (∀ (x : α), @eq.{v+1} (β x) (f₁ x) (f₂ x)) → @eq.{(max (u+1) (v+1))} (Π (x : α), β x) f₁ f₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  have ∀ b, f₂ b = g₂ b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₁ : α → option.{v} β,
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (g₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β g₁ g₂ hg)
         x),
h : @eq.{(max (u+1) (v+1))} (α → option.{v} β) f₁ g₁
⊢ ∀ (b : β), @eq.{u+1} (option.{u} α) (f₂ b) (g₂ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34      subst h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+1) (v+1))} (α → option.{v} β) f₁ g₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₁ : α → option.{v} β,
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (g₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β g₁ g₂ hg)
         x),
h : @eq.{(max (u+1) (v+1))} (α → option.{v} β) f₁ g₁
⊢ ∀ (b : β), @eq.{u+1} (option.{u} α) (f₂ b) (g₂ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x)
⊢ ∀ (b : β), @eq.{u+1} (option.{u} α) (f₂ b) (g₂ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35      assume b,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x)
⊢ ∀ (b : β), @eq.{u+1} (option.{u} α) (f₂ b) (g₂ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (g₂ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36      have hf := λ a, hf a b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : α) (b : β), iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (g₂ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a))
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (g₂ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37      have hg := λ a, hg a b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : α) (b : β), iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a))
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (g₂ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a))
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (g₂ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38      cases h : g₂ b with a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='g₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a))
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (g₂ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.none.{u} α)
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.none.{u} α)

case option.some
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
a : α,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.some.{u} α a)
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39      { simp only [h, option.not_mem_none, false_iff] at hg,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.not_mem_none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='false_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 501, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (g₂ b) (@option.none.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (a : α), not (@has_mem.mem.{?l_1 ?l_1} α (option.{?l_1} α) (@option.has_mem.{?l_1} α) a (@option.none.{?l_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (iff false a) (not a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.none.{u} α)
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.none.{u} α)

case option.some
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
a : α,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.some.{u} α a)
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.none.{u} α)
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.none.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.none.{u} α),
hg : ∀ (a : α), not (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a))
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.none.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40        simp only [hg, iff_false] at hf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff_false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 498, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : α), not (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (iff a false) (not a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.none.{u} α),
hg : ∀ (a : α), not (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a))
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.none.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.none.{u} α),
hg : ∀ (a : α), not (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hf : ∀ (a : α), not (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.none.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41        rwa [option.eq_none_iff_forall_not_mem] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='option.eq_none_iff_forall_not_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {o : option.{u} α}, iff (@eq.{u+1} (option.{u} α) o (@option.none.{u} α)) (∀ (a : α), not (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a o))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.none.{u} α),
hg : ∀ (a : α), not (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hf : ∀ (a : α), not (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.none.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.none.{u} α),
hg : ∀ (a : α), not (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hf : ∀ (a : α), not (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
⊢ ∀ (a : α), not (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.none.{u} α),
hg : ∀ (a : α), not (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hf : ∀ (a : α), not (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.none.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
a : α,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.some.{u} α a)
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42      { rw [← option.mem_def, hf, ← hg, h, option.mem_def] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='option.mem_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.mem_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/defs.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/defs.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α} {b : option.{u} α}, iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a b) (@eq.{u+1} (option.{u} α) b (@option.some.{u} α a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : α), iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : α), iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (option.{u} α) (g₂ b) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α} {b : option.{u} α}, iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a b) (@eq.{u+1} (option.{u} α) b (@option.some.{u} α a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
a : α,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.some.{u} α a)
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
a : α,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.some.{u} α a)
⊢ @has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
a : α,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.some.{u} α a)
⊢ @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
a : α,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.some.{u} α a)
⊢ @has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
a : α,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.some.{u} α a)
⊢ @has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ g₂ hg)
         x),
b : β,
hf :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
hg :
  ∀ (a : α),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
a : α,
h : @eq.{u+1} (option.{u} α) (g₂ b) (@option.some.{u} α a)
⊢ @eq.{u+1} (option.{u} α) (f₂ b) (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  by simp [*, funext_iff]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='function.funext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/function.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {β : α → Sort ?l_2} {f₁ f₂ : Π (x : α), β x}, iff (@eq.{(imax ?l_1 ?l_2)} (Π (x : α), β x) f₁ f₂) (∀ (a : α), @eq.{?l_2} (β a) (f₁ a) (f₂ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₁ : α → option.{v} β,
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (g₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β g₁ g₂ hg)
         x),
h : @eq.{(max (u+1) (v+1))} (α → option.{v} β) f₁ g₁,
this : ∀ (b : β), @eq.{u+1} (option.{u} α) (f₂ b) (g₂ b)
⊢ @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.mk.{u v} α β f₁ f₂ hf)
    (@pequiv.mk.{u v} α β g₁ g₂ hg)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
ext :
  ∀ {f g : pequiv.{u v} α β},
    (∀ (x : α),
       @eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
            x)) →
    @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g,
f₁ : α → option.{v} β,
f₂ : β → option.{u} α,
hf :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (f₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (f₁ a)),
g₁ : α → option.{v} β,
g₂ : β → option.{u} α,
hg :
  ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (g₂ b))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (g₁ a)),
h :
  ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β f₁ f₂ hf)
         x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
         (@pequiv.mk.{u v} α β g₁ g₂ hg)
         x),
h : @eq.{(max (u+1) (v+1))} (α → option.{v} β) f₁ g₁,
this : ∀ (b : β), @eq.{u+1} (option.{u} α) (f₂ b) (g₂ b)
⊢ @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.mk.{u v} α β f₁ f₂ hf)
    (@pequiv.mk.{u v} α β g₁ g₂ hg)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  lemma ext_iff {f g : α ≃. β} : f = g ↔ ∀ x, f x = g x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  ⟨congr_fun ∘ congr_arg _, ext⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : α → Type v} {f g : Π (x : α), β x}, @eq.{(max (u+1) (v+1))} (Π (x : α), β x) f g → ∀ (a : α), @eq.{v+1} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β φ : Prop}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type (max u v)} {a₁ a₂ : α} (f : α → β), @eq.{(max (u+1) (v+1))} α a₁ a₂ → @eq.{(max (u+1) (v+1))} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {f g : pequiv.{u v} α β}, (∀ (x : α), @eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g x)) → @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  @[refl] protected def refl (α : Type*) : α ≃. α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='reflexive relation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  { to_fun := some,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51    inv_fun := some,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52    inv := λ _ _, eq_comm }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {a b : α}, iff (@eq.{u} α a b) (@eq.{u} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  @[symm] protected def symm (f : α ≃. β) : β ≃. α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type u → Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='symmetric relation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  { to_fun := f.2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → β → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    inv_fun := f.1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.to_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → α → option.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    inv := λ _ _, (f.inv _ _).symm }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='iff.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 254, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} (c : pequiv.{u v} α β) (a : α) (b : β), iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (@pequiv.inv_fun.{u v} α β c b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@pequiv.to_fun.{u v} α β c a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {a b : Prop}, iff a b → iff b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  lemma mem_iff_mem (f : α ≃. β) : ∀ {a : α} {b : β}, a ∈ f.symm b ↔ b ∈ f a := f.3</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} (c : pequiv.{u v} α β) (a : α) (b : β), iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (@pequiv.inv_fun.{u v} α β c b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@pequiv.to_fun.{u v} α β c a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  lemma eq_some_iff (f : α ≃. β) : ∀ {a : α} {b : β}, f.symm b = some a ↔ f a = some b := f.3</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} (c : pequiv.{u v} α β) (a : α) (b : β), iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (@pequiv.inv_fun.{u v} α β c b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@pequiv.to_fun.{u v} α β c a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  @[trans] protected def trans (f : α ≃. β) (g : β ≃. γ) : pequiv α γ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type w → Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='transitive relation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  { to_fun := λ a, (f a).bind g,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type w}, option.{v} α → (α → option.{w} β) → option.{w} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    inv_fun := λ a, (g.symm a).bind f.symm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.bind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type w}, pequiv.{v w} α β → pequiv.{w v} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type u}, option.{v} α → (α → option.{u} β) → option.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66    inv := λ a b, by simp [*, and.comm, eq_some_iff f, eq_some_iff g] at * }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='and.comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.eq_some_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.eq_some_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 380, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff (and a b) (and b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β) {a : α} {b : β}, iff (@eq.{u+1} (option.{u} α) (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α) (@pequiv.symm.{u v} α β f) b) (@option.some.{u} α a)) (@eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) (@option.some.{v} β b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {β : Type w} (f : pequiv.{v w} α β) {a : α} {b : β}, iff (@eq.{v+1} (option.{v} α) (@coe_fn.{(max (w+1) (v+1)) (max (w+1) (v+1))} (pequiv.{w v} β α) (@pequiv.has_coe_to_fun.{w v} β α) (@pequiv.symm.{v w} α β f) b) (@option.some.{v} α a)) (@eq.{w+1} (option.{w} β) (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} α β) (@pequiv.has_coe_to_fun.{v w} α β) f a) (@option.some.{w} β b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
f : pequiv.{u v} α β,
g : pequiv.{v w} β γ,
a : α,
b : γ
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@option.bind.{v u} β α
          (@coe_fn.{(max (w+1) (v+1)) (max (w+1) (v+1))} (pequiv.{w v} γ β) (@pequiv.has_coe_to_fun.{w v} γ β)
             (@pequiv.symm.{v w} β γ g)
             b)
          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
             (@pequiv.symm.{u v} α β f))))
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) b
       (@option.bind.{v w} β γ
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
          (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ) g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  @[simp] lemma refl_apply (a : α) : pequiv.refl α a = some a := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  @[simp] lemma symm_refl : (pequiv.refl α).symm = pequiv.refl α := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, pequiv.{u u} α β → pequiv.{u u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  @[simp] lemma symm_refl_apply (a : α) : (pequiv.refl α).symm a = some a := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, pequiv.{u u} α β → pequiv.{u u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  @[simp] lemma symm_symm (f : α ≃. β) : f.symm.symm = f := by cases f; refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type u}, pequiv.{v u} α β → pequiv.{u v} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.symm.{v u} β α (@pequiv.symm.{u v} α β f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.symm.{v u} β α (@pequiv.symm.{u v} α β f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  @[simp] lemma symm_symm_apply (f : α ≃. β) (a : α) : f.symm.symm a = f a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type u}, pequiv.{v u} α β → pequiv.{u v} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  by rw symm_symm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='pequiv.symm_symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 74, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β), @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.symm.{v u} β α (@pequiv.symm.{u v} α β f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a : α
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@pequiv.symm.{v u} β α (@pequiv.symm.{u v} α β f))
       a)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a : α
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@pequiv.symm.{v u} β α (@pequiv.symm.{u v} α β f))
       a)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  lemma symm_injective : function.injective (@pequiv.symm α β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  injective_of_has_left_inverse ⟨_, symm_symm⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='function.injective_of_has_left_inverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pequiv.symm_symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 74, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u v)} {β : Type (max v u)} {f : α → β}, @function.has_left_inverse.{(max (u+1) (v+1)) (max (v+1) (u+1))} α β f → @function.injective.{(max (u+1) (v+1)) (max (v+1) (u+1))} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β), @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.symm.{v u} β α (@pequiv.symm.{u v} α β f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  lemma trans_assoc (f : α ≃. β) (g : β ≃. γ) (h : γ ≃. δ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='δ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type w → Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w → Type x → Type (max w x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    (f.trans g).trans h = f.trans (g.trans h) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type w} {γ : Type x}, pequiv.{u w} α β → pequiv.{w x} β γ → pequiv.{u x} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{w x} γ δ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u x)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type x}, pequiv.{u v} α β → pequiv.{v x} β γ → pequiv.{u x} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type w} {γ : Type x}, pequiv.{v w} α β → pequiv.{w x} β γ → pequiv.{v x} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{w x} γ δ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  ext (λ _, option.bind_assoc _ _ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.bind_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 76, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type x} {f g : pequiv.{u x} α β}, (∀ (x : α), @eq.{x+1} (option.{x} β) (@coe_fn.{(max (u+1) (x+1)) (max (u+1) (x+1))} (pequiv.{u x} α β) (@pequiv.has_coe_to_fun.{u x} α β) f x) (@coe_fn.{(max (u+1) (x+1)) (max (u+1) (x+1))} (pequiv.{u x} α β) (@pequiv.has_coe_to_fun.{u x} α β) g x)) → @eq.{(max (u+1) (x+1))} (pequiv.{u x} α β) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type v} {β : Type w} {γ : Type x} (x : option.{v} α) (f : α → option.{w} β) (g : β → option.{x} γ), @eq.{x+1} (option.{x} γ) (@option.bind.{w x} β γ (@option.bind.{v w} α β x f) g) (@option.bind.{v x} α γ x (λ (y : α), @option.bind.{w x} β γ (f y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  lemma mem_trans (f : α ≃. β) (g : β ≃. γ) (a : α) (c : γ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type w → Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87    c ∈ f.trans g a ↔ ∃ b, b ∈ f a ∧ c ∈ g b := option.bind_eq_some&#x27;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='option.bind_eq_some&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type w} [c : has_mem.{w w} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type w} [c : has_mem.{w w} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {β : Type w} {x : option.{v} α} {f : α → option.{w} β} {b : β}, iff (@eq.{w+1} (option.{w} β) (@option.bind.{v w} α β x f) (@option.some.{w} β b)) (@Exists.{v+1} α (λ (a : α), and (@eq.{v+1} (option.{v} α) x (@option.some.{v} α a)) (@eq.{w+1} (option.{w} β) (f a) (@option.some.{w} β b))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  lemma trans_eq_some (f : α ≃. β) (g : β ≃. γ) (a : α) (c : γ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type w → Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90    f.trans g a = some c ↔ ∃ b, f a = some b ∧ g b = some c := option.bind_eq_some&#x27;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='option.bind_eq_some&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {β : Type w} {x : option.{v} α} {f : α → option.{w} β} {b : β}, iff (@eq.{w+1} (option.{w} β) (@option.bind.{v w} α β x f) (@option.some.{w} β b)) (@Exists.{v+1} α (λ (a : α), and (@eq.{v+1} (option.{v} α) x (@option.some.{v} α a)) (@eq.{w+1} (option.{w} β) (f a) (@option.some.{w} β b))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  lemma trans_eq_none (f : α ≃. β) (g : β ≃. γ) (a : α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type w → Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93    f.trans g a = none ↔ (∀ b c, b ∉ f a ∨ c ∉ g b) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  by simp only [eq_none_iff_forall_not_mem, mem_trans]; push_neg; tauto</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='option.eq_none_iff_forall_not_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.mem_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/push_neg.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tauto.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {o : option.{?l_1} α}, iff (@eq.{?l_1+1} (option.{?l_1} α) o (@option.none.{?l_1} α)) (∀ (a : α), not (@has_mem.mem.{?l_1 ?l_1} α (option.{?l_1} α) (@option.has_mem.{?l_1} α) a o))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} (f : pequiv.{?l_1 ?l_2} α β) (g : pequiv.{?l_2 ?l_3} β γ) (a : α) (c : γ), iff (@has_mem.mem.{?l_3 ?l_3} γ (option.{?l_3} γ) (@option.has_mem.{?l_3} γ) c (@coe_fn.{(max (?l_1+1) (?l_3+1)) (max (?l_1+1) (?l_3+1))} (pequiv.{?l_1 ?l_3} α γ) (@pequiv.has_coe_to_fun.{?l_1 ?l_3} α γ) (@pequiv.trans.{?l_1 ?l_2 ?l_3} α β γ f g) a)) (@Exists.{?l_2+1} β (λ (b : β), and (@has_mem.mem.{?l_2 ?l_2} β (option.{?l_2} β) (@option.has_mem.{?l_2} β) b (@coe_fn.{(max (?l_1+1) (?l_2+1)) (max (?l_1+1) (?l_2+1))} (pequiv.{?l_1 ?l_2} α β) (@pequiv.has_coe_to_fun.{?l_1 ?l_2} α β) f a)) (@has_mem.mem.{?l_3 ?l_3} γ (option.{?l_3} γ) (@option.has_mem.{?l_3} γ) c (@coe_fn.{(max (?l_2+1) (?l_3+1)) (max (?l_2+1) (?l_3+1))} (pequiv.{?l_2 ?l_3} β γ) (@pequiv.has_coe_to_fun.{?l_2 ?l_3} β γ) g b))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Push negations in the goal of some assumption.
For instance, given `h : ¬ ∀ x, ∃ y, x ≤ y`, will be transformed by `push_neg at h` into
`h : ∃ x, ∀ y, y &lt; x`. Variables names are conserved.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`tauto` breaks down assumptions of the form `_ ∧ _`, `_ ∨ _`, `_ ↔ _` and `∃ _, _`
and splits a goal of the form `_ ∧ _`, `_ ↔ _` or `∃ _, _` until it can be discharged
using `reflexivity` or `solve_by_elim`.
This is a finishing tactic: it either closes the goal of raises an error.
The variant `tauto!` uses the law of excluded middle.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='push_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='tauto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
f : pequiv.{u v} α β,
g : pequiv.{v w} β γ,
a : α
⊢ iff
    (@eq.{w+1} (option.{w} γ)
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@pequiv.trans.{u v w} α β γ f g)
          a)
       (@option.none.{w} γ))
    (∀ (b : β) (c : γ),
       or
         (not
            (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
                  f
                  a)))
         (not
            (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) c
               (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ)
                  g
                  b))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tauto.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`tauto` breaks down assumptions of the form `_ ∧ _`, `_ ∨ _`, `_ ↔ _` and `∃ _, _`
and splits a goal of the form `_ ∧ _`, `_ ↔ _` or `∃ _, _` until it can be discharged
using `reflexivity` or `solve_by_elim`.
This is a finishing tactic: it either closes the goal of raises an error.
The variant `tauto!` uses the law of excluded middle.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='tauto'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
f : pequiv.{u v} α β,
g : pequiv.{v w} β γ,
a : α
⊢ iff
    (@eq.{w+1} (option.{w} γ)
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@pequiv.trans.{u v w} α β γ f g)
          a)
       (@option.none.{w} γ))
    (∀ (b : β) (c : γ),
       or
         (not
            (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
                  f
                  a)))
         (not
            (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) c
               (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ)
                  g
                  b))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  @[simp] lemma refl_trans (f : α ≃. β) : (pequiv.refl α).trans f = f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u} {γ : Type v}, pequiv.{u u} α β → pequiv.{u v} β γ → pequiv.{u v} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  by ext; dsimp [pequiv.trans]; refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3}, pequiv.{?l_1 ?l_2} α β → pequiv.{?l_2 ?l_3} β γ → pequiv.{?l_1 ?l_3} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.trans.{u u v} α α β (pequiv.refl.{u} α) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.trans.{u u v} α α β (pequiv.refl.{u} α) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  @[simp] lemma trans_refl (f : α ≃. β) : f.trans (pequiv.refl β) = f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β γ : Type v}, pequiv.{u v} α β → pequiv.{v v} β γ → pequiv.{u v} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  by ext; dsimp [pequiv.trans]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3}, pequiv.{?l_1 ?l_2} α β → pequiv.{?l_2 ?l_3} β γ → pequiv.{?l_1 ?l_3} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.trans.{u v v} α β β f (pequiv.refl.{v} β)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.trans.{u v v} α β β f (pequiv.refl.{v} β)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  @[simp] lemma refl_trans_apply (f : α ≃. β) (a : α) : (pequiv.refl α).trans f a = f a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u} {γ : Type v}, pequiv.{u u} α β → pequiv.{u v} β γ → pequiv.{u v} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  by rw refl_trans</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='pequiv.refl_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 96, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β), @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.trans.{u u v} α α β (pequiv.refl.{u} α) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a : α
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@pequiv.trans.{u u v} α α β (pequiv.refl.{u} α) f)
       a)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a : α
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@pequiv.trans.{u u v} α α β (pequiv.refl.{u} α) f)
       a)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  @[simp] lemma trans_refl_apply (f : α ≃. β) (a : α) : f.trans (pequiv.refl β) a = f a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β γ : Type v}, pequiv.{u v} α β → pequiv.{v v} β γ → pequiv.{u v} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  by rw trans_refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='pequiv.trans_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 99, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β), @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.trans.{u v v} α β β f (pequiv.refl.{v} β)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a : α
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@pequiv.trans.{u v v} α β β f (pequiv.refl.{v} β))
       a)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a : α
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@pequiv.trans.{u v v} α β β f (pequiv.refl.{v} β))
       a)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  protected lemma inj (f : α ≃. β) {a₁ a₂ : α} {b : β} (h₁ : b ∈ f a₁) (h₂ : b ∈ f a₂) : a₁ = a₂ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  by rw ← mem_iff_mem at *; cases h : f.symm b; simp * at *</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pequiv.mem_iff_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 59, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} (f : pequiv.{?l_1 ?l_2} α β) {a : α} {b : β}, iff (@has_mem.mem.{?l_1 ?l_1} α (option.{?l_1} α) (@option.has_mem.{?l_1} α) a (@coe_fn.{(max (?l_2+1) (?l_1+1)) (max (?l_2+1) (?l_1+1))} (pequiv.{?l_2 ?l_1} β α) (@pequiv.has_coe_to_fun.{?l_2 ?l_1} β α) (@pequiv.symm.{?l_1 ?l_2} α β f) b)) (@has_mem.mem.{?l_2 ?l_2} β (option.{?l_2} β) (@option.has_mem.{?l_2} β) b (@coe_fn.{(max (?l_1+1) (?l_2+1)) (max (?l_1+1) (?l_2+1))} (pequiv.{?l_1 ?l_2} α β) (@pequiv.has_coe_to_fun.{?l_1 ?l_2} α β) f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₁ a₂ : α,
b : β,
h₁ :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a₁),
h₂ :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a₂)
⊢ @eq.{u+1} α a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₁ a₂ : α,
b : β,
h₁ :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a₁),
h₂ :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a₂)
⊢ @eq.{u+1} α a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  lemma injective_of_forall_ne_is_some (f : α ≃. β) (a₂ : α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    (h : ∀ (a₁ : α), a₁ ≠ a₂ → is_some (f a₁)) : injective f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='option.is_some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, option.{u} α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  injective_of_has_left_inverse</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='function.injective_of_has_left_inverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {f : α → β}, @function.has_left_inverse.{u+1 v+1} α β f → @function.injective.{u+1 v+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    ⟨λ b, option.rec_on b a₂ (λ b&#x27;, option.rec_on (f.symm b&#x27;) a₂ id),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='option.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} {C : option.{v} α → Type u} (n : option.{v} α), C (@option.none.{v} α) → (Π (val : α), C (@option.some.{v} α val)) → C n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {C : option.{u} α → Type u} (n : option.{u} α), C (@option.none.{u} α) → (Π (val : α), C (@option.some.{u} α val)) → C n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115      λ x, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116        classical,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Make every propositions in the context decidable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='classical'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117        cases hfx : f x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.none.{v} β)
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@option.none.{v} β))
    x

case option.some
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
val : β,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.some.{v} β val)
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@option.some.{v} β val))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118        { have : x = a₂, from not_imp_comm.1 (h x) (hfx.symm ▸ by simp), simp [this] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='not_imp_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hfx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop} [_inst_1 : decidable a] [_inst_2 : decidable b], iff (not a → b) (not b → a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a₁ : α), @ne.{u+1} α a₁ a₂ → @coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{v} β (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x) (@option.none.{v} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {P : α → Prop} {a b : α}, @eq.{v+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} α x a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.none.{v} β)
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@option.none.{v} β))
    x

case option.some
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
val : β,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.some.{v} β val)
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@option.some.{v} β val))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.none.{v} β)
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@option.none.{v} β))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.none.{v} β)
⊢ @eq.{u+1} α x a₂

α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.none.{v} β),
this : @eq.{u+1} α x a₂
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@option.none.{v} β))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.none.{v} β)
⊢ not (@coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{v} β (@option.none.{v} β)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.none.{v} β)
⊢ @eq.{u+1} α x a₂

α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.none.{v} β),
this : @eq.{u+1} α x a₂
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@option.none.{v} β))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.none.{v} β),
this : @eq.{u+1} α x a₂
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@option.none.{v} β))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
val : β,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.some.{v} β val)
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@option.some.{v} β val))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119        { simp only [hfx], rw [(eq_some_iff f).2 hfx], refl }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='hfx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pequiv.eq_some_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hfx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x) (@option.some.{v} β val)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β) {a : α} {b : β}, iff (@eq.{u+1} (option.{u} α) (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α) (@pequiv.symm.{u v} α β f) b) (@option.some.{u} α a)) (@eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) (@option.some.{v} β b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x) (@option.some.{v} β val)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
val : β,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.some.{v} β val)
⊢ @eq.{u+1} α
    ((λ (b : option.{v} β),
        @option.rec_on.{u+1 v} β (λ (_x : option.{v} β), α) b a₂
          (λ (b&#x27; : β),
             @option.rec_on.{u+1 u} α (λ (_x : option.{u} α), α)
               (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                  (@pequiv.symm.{u v} α β f)
                  b&#x27;)
               a₂
               (@id.{u+1} α)))
       (@option.some.{v} β val))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
val : β,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.some.{v} β val)
⊢ @eq.{u+1} α
    (@option.rec.{u+1 u} α (λ (_x : option.{u} α), α) a₂ (@id.{u+1} α)
       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
          (@pequiv.symm.{u v} α β f)
          val))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
val : β,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.some.{v} β val)
⊢ @eq.{u+1} α (@option.rec.{u+1 u} α (λ (_x : option.{u} α), α) a₂ (@id.{u+1} α) (@option.some.{u} α x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a₂ : α,
h :
  ∀ (a₁ : α),
    @ne.{u+1} α a₁ a₂ →
    @coe_sort.{1 1} bool coe_sort_bool
      (@option.is_some.{v} β
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a₁)),
x : α,
_inst : Π (a : Prop), decidable a,
val : β,
hfx :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.some.{v} β val)
⊢ @eq.{u+1} α (@option.rec.{u+1 u} α (λ (_x : option.{u} α), α) a₂ (@id.{u+1} α) (@option.some.{u} α x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120      end⟩</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  lemma injective_of_forall_is_some {f : α ≃. β}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123    (h : ∀ (a : α), is_some (f a)) : injective f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='option.is_some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, option.{u} α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  (classical.em (nonempty α)).elim</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='classical.em'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 69, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (p : Prop), or p (not p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    (λ hn, injective_of_forall_ne_is_some f (classical.choice hn)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.injective_of_forall_ne_is_some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='classical.choice'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nonempty.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β) (a₂ : α), (∀ (a₁ : α), @ne.{u+1} α a₁ a₂ → @coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{v} β (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a₁))) → @function.injective.{u+1 v+1} α (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, nonempty.{u+1} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nonempty.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126      (λ a _, h a))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} α a (@classical.choice.{u+1} α hn)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (a : α), @coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{v} β (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    (λ hn x, (hn ⟨x⟩).elim)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='false.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='not (nonempty.{u+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='not (nonempty.{u+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {C : Prop}, false → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  section of_set</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  variables (s : set α) [decidable_pred s]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  def of_set (s : set α) [decidable_pred s] : α ≃. α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  { to_fun := λ a, if a ∈ s then some a else none,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    inv_fun := λ a, if a ∈ s then some a else none,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135    inv := λ a b, by split_ifs; finish [eq_comm] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {a b : α}, iff (@eq.{?l_1} α a b) (@eq.{?l_1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
a b : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@ite.{u+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) b s)
          (@set.decidable_mem.{u} α s (λ (a : α), _inst_2 a) b)
          (option.{u} α)
          (@option.some.{u} α b)
          (@option.none.{u} α)))
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) b
       (@ite.{u+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
          (@set.decidable_mem.{u} α s (λ (a : α), _inst_2 a) a)
          (option.{u} α)
          (@option.some.{u} α a)
          (@option.none.{u} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  lemma mem_of_set_self_iff {s : set α} [decidable_pred s] {a : α} : a ∈ of_set s a ↔ a ∈ s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_2 : @decidable_pred.{u+1} α s], pequiv.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  by dsimp [of_set]; split_ifs; simp *</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} (s : set.{?l_1} α) [_inst_2 : @decidable_pred.{?l_1+1} α s], pequiv.{?l_1 ?l_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
a : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
          (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a))
          a))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
a : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
          (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a))
          a))
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  lemma mem_of_set_iff {s : set α} [decidable_pred s] {a b : α} : a ∈ of_set s b ↔ a = b ∧ a ∈ s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_2 : @decidable_pred.{u+1} α s], pequiv.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  by dsimp [of_set]; split_ifs; split; finish</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} (s : set.{?l_1} α) [_inst_2 : @decidable_pred.{?l_1+1} α s], pequiv.{?l_1 ?l_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
a b : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
          (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a))
          b))
    (and (@eq.{u+1} α a b) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
a b : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
          (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a))
          b))
    (and (@eq.{u+1} α a b) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  @[simp] lemma of_set_eq_some_self_iff {s : set α} {h : decidable_pred s} {a : α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Sort u}, (α → Prop) → Sort (max u 1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    of_set s a = some a ↔ a ∈ s := mem_of_set_self_iff</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv.mem_of_set_self_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 137, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_2 : @decidable_pred.{u+1} α s], pequiv.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α} [_inst_2 : @decidable_pred.{u+1} α s] {a : α}, iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) a)) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  @[simp] lemma of_set_eq_some_iff {s : set α} {h : decidable_pred s} {a b : α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Sort u}, (α → Prop) → Sort (max u 1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147    of_set s b = some a ↔ a = b ∧ a ∈ s := mem_of_set_iff</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv.mem_of_set_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 140, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_2 : @decidable_pred.{u+1} α s], pequiv.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α} [_inst_2 : @decidable_pred.{u+1} α s] {a b : α}, iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) b)) (and (@eq.{u+1} α a b) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  @[simp] lemma of_set_symm : (of_set s).symm = of_set s := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_2 : @decidable_pred.{u+1} α s], pequiv.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, pequiv.{u u} α β → pequiv.{u u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_2 : @decidable_pred.{u+1} α s], pequiv.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  @[simp] lemma of_set_univ : of_set set.univ = pequiv.refl α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_2 : @decidable_pred.{u+1} α s], pequiv.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  by ext; dsimp [of_set]; simp [eq_comm]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} (s : set.{?l_1} α) [_inst_2 : @decidable_pred.{?l_1+1} α s], pequiv.{?l_1 ?l_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {a b : α}, iff (@eq.{?l_1} α a b) (@eq.{?l_1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u
⊢ @eq.{u+1} (pequiv.{u u} α α)
    (@pequiv.of_set.{u} α (@set.univ.{u} α) (λ (a : α), @set.univ_decidable.{u} α a))
    (pequiv.refl.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u
⊢ @eq.{u+1} (pequiv.{u u} α α)
    (@pequiv.of_set.{u} α (@set.univ.{u} α) (λ (a : α), @set.univ_decidable.{u} α a))
    (pequiv.refl.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  @[simp] lemma of_set_eq_refl {s : set α} [decidable_pred s] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155    of_set s = pequiv.refl α ↔ s = set.univ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_2 : @decidable_pred.{u+1} α s], pequiv.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  ⟨λ h, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
h : @eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α)
⊢ @eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    rw [set.eq_univ_iff_forall],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.eq_univ_iff_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 248, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, iff (@eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α)) (∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
h : @eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α)
⊢ @eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
h : @eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α)
⊢ ∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158    intro,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
h : @eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α)
⊢ ∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
h : @eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α),
x : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159    rw [← mem_of_set_self_iff, h],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pequiv.mem_of_set_self_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 137, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α} [_inst_2 : @decidable_pred.{u+1} α s] {a : α}, iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) a)) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
h : @eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α),
x : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
h : @eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α),
x : α
⊢ @has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) x
    (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
       (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
h : @eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α),
x : α
⊢ @has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) x
    (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α) (pequiv.refl.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160    exact rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
h : @eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α),
x : α
⊢ @has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) x
    (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α) (pequiv.refl.{u} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  end, λ h, by simp only [of_set_univ.symm, h]; congr⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{?l_1+1} (pequiv.{?l_1 ?l_1} ?m_2 ?m_2) (pequiv.refl.{?l_1} ?m_2) (@pequiv.of_set.{?l_1} ?m_2 (@set.univ.{?l_1} ?m_2) (λ (a : ?m_2), @set.univ_decidable.{?l_1} ?m_2 a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='lime'><a title='α : Type u,
s : set.{u} α,
_inst_2 : @decidable_pred.{u+1} α s,
h : @eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α)
⊢ @eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  end of_set</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  lemma symm_trans_rev (f : α ≃. β) (g : β ≃. γ) : (f.trans g).symm = g.symm.trans f.symm := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type w → Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type w}, pequiv.{u w} α β → pequiv.{w u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max w u)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type w}, pequiv.{v w} α β → pequiv.{w v} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type w} {β : Type v} {γ : Type u}, pequiv.{w v} α β → pequiv.{v u} β γ → pequiv.{w u} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type (max w u)} {a : α}, @eq.{(max (w+1) (u+1))} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  lemma trans_symm (f : α ≃. β) : f.trans f.symm = of_set {a | (f a).is_some} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.is_some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type u}, pequiv.{u v} α β → pequiv.{v u} β γ → pequiv.{u u} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_2 : @decidable_pred.{u+1} α s], pequiv.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, option.{v} α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ @eq.{u+1} (pequiv.{u u} α α) (@pequiv.trans.{u v u} α β α f (@pequiv.symm.{u v} α β f))
    (@pequiv.of_set.{u} α
       (@set_of.{u} α
          (λ (a : α),
             @coe_sort.{1 1} bool coe_sort_bool
               (@option.is_some.{v} β
                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                     (@pequiv.has_coe_to_fun.{u v} α β)
                     f
                     a))))
       (λ (a : α),
          @set.decidable_set_of.{u} α
            (λ (a : α),
               @coe_sort.{1 1} bool coe_sort_bool
                 (@option.is_some.{v} β
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a)))
            (λ (a : α),
               bool.decidable_eq
                 (@option.is_some.{v} β
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a))
                 bool.tt)
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    ext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ @eq.{u+1} (pequiv.{u u} α α) (@pequiv.trans.{u v u} α β α f (@pequiv.symm.{u v} α β f))
    (@pequiv.of_set.{u} α
       (@set_of.{u} α
          (λ (a : α),
             @coe_sort.{1 1} bool coe_sort_bool
               (@option.is_some.{v} β
                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                     (@pequiv.has_coe_to_fun.{u v} α β)
                     f
                     a))))
       (λ (a : α),
          @set.decidable_set_of.{u} α
            (λ (a : α),
               @coe_sort.{1 1} bool coe_sort_bool
                 (@option.is_some.{v} β
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a)))
            (λ (a : α),
               bool.decidable_eq
                 (@option.is_some.{v} β
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a))
                 bool.tt)
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
          (@pequiv.trans.{u v u} α β α f (@pequiv.symm.{u v} α β f))
          x))
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
          (@pequiv.of_set.{u} α
             (@set_of.{u} α
                (λ (a : α),
                   @coe_sort.{1 1} bool coe_sort_bool
                     (@option.is_some.{v} β
                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                           (@pequiv.has_coe_to_fun.{u v} α β)
                           f
                           a))))
             (λ (a : α),
                @set.decidable_set_of.{u} α
                  (λ (a : α),
                     @coe_sort.{1 1} bool coe_sort_bool
                       (@option.is_some.{v} β
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)))
                  (λ (a : α),
                     bool.decidable_eq
                       (@option.is_some.{v} β
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a))
                       bool.tt)
                  a))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170    dsimp [pequiv.trans],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3}, pequiv.{?l_1 ?l_2} α β → pequiv.{?l_2 ?l_3} β γ → pequiv.{?l_1 ?l_3} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
          (@pequiv.trans.{u v u} α β α f (@pequiv.symm.{u v} α β f))
          x))
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
          (@pequiv.of_set.{u} α
             (@set_of.{u} α
                (λ (a : α),
                   @coe_sort.{1 1} bool coe_sort_bool
                     (@option.is_some.{v} β
                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                           (@pequiv.has_coe_to_fun.{u v} α β)
                           f
                           a))))
             (λ (a : α),
                @set.decidable_set_of.{u} α
                  (λ (a : α),
                     @coe_sort.{1 1} bool coe_sort_bool
                       (@option.is_some.{v} β
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)))
                  (λ (a : α),
                     bool.decidable_eq
                       (@option.is_some.{v} β
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a))
                       bool.tt)
                  a))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@option.bind.{v u} β α
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
             (@pequiv.symm.{u v} α β f))))
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
          (@pequiv.of_set.{u} α
             (@set_of.{u} α
                (λ (a : α),
                   @coe_sort.{1 1} bool coe_sort_bool
                     (@option.is_some.{v} β
                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                           (@pequiv.has_coe_to_fun.{u v} α β)
                           f
                           a))))
             (@set.decidable_set_of.{u} α
                (λ (a : α),
                   @coe_sort.{1 1} bool coe_sort_bool
                     (@option.is_some.{v} β
                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                           (@pequiv.has_coe_to_fun.{u v} α β)
                           f
                           a)))
                (λ (a : α),
                   bool.decidable_eq
                     (@option.is_some.{v} β
                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                           (@pequiv.has_coe_to_fun.{u v} α β)
                           f
                           a))
                     bool.tt)))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    simp only [eq_some_iff f, option.is_some_iff_exists, option.mem_def, bind_eq_some&#x27;, of_set_eq_some_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='pequiv.eq_some_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.is_some_iff_exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.mem_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.bind_eq_some&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.of_set_eq_some_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/defs.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 146, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β) {a : α} {b : β}, iff (@eq.{u+1} (option.{u} α) (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α) (@pequiv.symm.{u v} α β f) b) (@option.some.{u} α a)) (@eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) (@option.some.{v} β b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {x : option.{?l_1} α}, iff (@coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{?l_1} α x)) (@Exists.{?l_1+1} α (λ (a : α), @eq.{?l_1+1} (option.{?l_1} α) x (@option.some.{?l_1} α a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {b : option.{?l_1} α}, iff (@has_mem.mem.{?l_1 ?l_1} α (option.{?l_1} α) (@option.has_mem.{?l_1} α) a b) (@eq.{?l_1+1} (option.{?l_1} α) b (@option.some.{?l_1} α a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {x : option.{?l_1} α} {f : α → option.{?l_2} β} {b : β}, iff (@eq.{?l_2+1} (option.{?l_2} β) (@option.bind.{?l_1 ?l_2} α β x f) (@option.some.{?l_2} β b)) (@Exists.{?l_1+1} α (λ (a : α), and (@eq.{?l_1+1} (option.{?l_1} α) x (@option.some.{?l_1} α a)) (@eq.{?l_2+1} (option.{?l_2} β) (f a) (@option.some.{?l_2} β b))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s : set.{?l_1} α} {h : @decidable_pred.{?l_1+1} α s} {a b : α}, iff (@eq.{?l_1+1} (option.{?l_1} α) (@coe_fn.{?l_1+1 ?l_1+1} (pequiv.{?l_1 ?l_1} α α) (@pequiv.has_coe_to_fun.{?l_1 ?l_1} α α) (@pequiv.of_set.{?l_1} α s (λ (a : α), h a)) b) (@option.some.{?l_1} α a)) (and (@eq.{?l_1+1} α a b) (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@option.bind.{v u} β α
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
             (@pequiv.symm.{u v} α β f))))
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
          (@pequiv.of_set.{u} α
             (@set_of.{u} α
                (λ (a : α),
                   @coe_sort.{1 1} bool coe_sort_bool
                     (@option.is_some.{v} β
                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                           (@pequiv.has_coe_to_fun.{u v} α β)
                           f
                           a))))
             (@set.decidable_set_of.{u} α
                (λ (a : α),
                   @coe_sort.{1 1} bool coe_sort_bool
                     (@option.is_some.{v} β
                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                           (@pequiv.has_coe_to_fun.{u v} α β)
                           f
                           a)))
                (λ (a : α),
                   bool.decidable_eq
                     (@option.is_some.{v} β
                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                           (@pequiv.has_coe_to_fun.{u v} α β)
                           f
                           a))
                     bool.tt)))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ iff
    (@Exists.{v+1} β
       (λ (a_1 : β),
          and
            (@eq.{v+1} (option.{v} β)
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
                  f
                  x)
               (@option.some.{v} β a_1))
            (@eq.{v+1} (option.{v} β)
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
                  f
                  a)
               (@option.some.{v} β a_1))))
    (and (@eq.{u+1} α a x)
       (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
          (@set_of.{u} α
             (λ (a : α),
                @Exists.{v+1} β
                  (λ (a_1 : β),
                     @eq.{v+1} (option.{v} β)
                       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                          (@pequiv.has_coe_to_fun.{u v} α β)
                          f
                          a)
                       (@option.some.{v} β a_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ iff
    (@Exists.{v+1} β
       (λ (a_1 : β),
          and
            (@eq.{v+1} (option.{v} β)
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
                  f
                  x)
               (@option.some.{v} β a_1))
            (@eq.{v+1} (option.{v} β)
               (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
                  f
                  a)
               (@option.some.{v} β a_1))))
    (and (@eq.{u+1} α a x)
       (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
          (@set_of.{u} α
             (λ (a : α),
                @Exists.{v+1} β
                  (λ (a_1 : β),
                     @eq.{v+1} (option.{v} β)
                       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                          (@pequiv.has_coe_to_fun.{u v} α β)
                          f
                          a)
                       (@option.some.{v} β a_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ @Exists.{v+1} β
    (λ (a_1 : β),
       and
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               x)
            (@option.some.{v} β a_1))
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)
            (@option.some.{v} β a_1))) →
  and (@eq.{u+1} α a x)
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@set_of.{u} α
          (λ (a : α),
             @Exists.{v+1} β
               (λ (a_1 : β),
                  @eq.{v+1} (option.{v} β)
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a)
                    (@option.some.{v} β a_1)))))

α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ and (@eq.{u+1} α a x)
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@set_of.{u} α
          (λ (a : α),
             @Exists.{v+1} β
               (λ (a_1 : β),
                  @eq.{v+1} (option.{v} β)
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a)
                    (@option.some.{v} β a_1))))) →
  @Exists.{v+1} β
    (λ (a_1 : β),
       and
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               x)
            (@option.some.{v} β a_1))
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)
            (@option.some.{v} β a_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173    { rintros ⟨b, hb₁, hb₂⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ @Exists.{v+1} β
    (λ (a_1 : β),
       and
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               x)
            (@option.some.{v} β a_1))
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)
            (@option.some.{v} β a_1))) →
  and (@eq.{u+1} α a x)
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@set_of.{u} α
          (λ (a : α),
             @Exists.{v+1} β
               (λ (a_1 : β),
                  @eq.{v+1} (option.{v} β)
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a)
                    (@option.some.{v} β a_1)))))

α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ and (@eq.{u+1} α a x)
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@set_of.{u} α
          (λ (a : α),
             @Exists.{v+1} β
               (λ (a_1 : β),
                  @eq.{v+1} (option.{v} β)
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a)
                    (@option.some.{v} β a_1))))) →
  @Exists.{v+1} β
    (λ (a_1 : β),
       and
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               x)
            (@option.some.{v} β a_1))
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)
            (@option.some.{v} β a_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ @Exists.{v+1} β
    (λ (a_1 : β),
       and
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               x)
            (@option.some.{v} β a_1))
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)
            (@option.some.{v} β a_1))) →
  and (@eq.{u+1} α a x)
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@set_of.{u} α
          (λ (a : α),
             @Exists.{v+1} β
               (λ (a_1 : β),
                  @eq.{v+1} (option.{v} β)
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a)
                    (@option.some.{v} β a_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α,
b : β,
hb₁ :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.some.{v} β b),
hb₂ :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.some.{v} β b)
⊢ and (@eq.{u+1} α a x)
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@set_of.{u} α
          (λ (a : α),
             @Exists.{v+1} β
               (λ (a_1 : β),
                  @eq.{v+1} (option.{v} β)
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a)
                    (@option.some.{v} β a_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174      exact ⟨pequiv.inj _ hb₂ hb₁, b, hb₂⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='pequiv.inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hb₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 108, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β) {a₁ a₂ : α} {b : β}, @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a₁) → @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a₂) → @eq.{u+1} α a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x) (@option.some.{v} β b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) (@option.some.{v} β b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α,
b : β,
hb₁ :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.some.{v} β b),
hb₂ :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.some.{v} β b)
⊢ and (@eq.{u+1} α a x)
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@set_of.{u} α
          (λ (a : α),
             @Exists.{v+1} β
               (λ (a_1 : β),
                  @eq.{v+1} (option.{v} β)
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a)
                    (@option.some.{v} β a_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ and (@eq.{u+1} α a x)
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@set_of.{u} α
          (λ (a : α),
             @Exists.{v+1} β
               (λ (a_1 : β),
                  @eq.{v+1} (option.{v} β)
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a)
                    (@option.some.{v} β a_1))))) →
  @Exists.{v+1} β
    (λ (a_1 : β),
       and
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               x)
            (@option.some.{v} β a_1))
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)
            (@option.some.{v} β a_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175    { simp {contextual := tt} }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
x a : α
⊢ and (@eq.{u+1} α a x)
    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
       (@set_of.{u} α
          (λ (a : α),
             @Exists.{v+1} β
               (λ (a_1 : β),
                  @eq.{v+1} (option.{v} β)
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a)
                    (@option.some.{v} β a_1))))) →
  @Exists.{v+1} β
    (λ (a_1 : β),
       and
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               x)
            (@option.some.{v} β a_1))
         (@eq.{v+1} (option.{v} β)
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)
            (@option.some.{v} β a_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  lemma symm_trans (f : α ≃. β) : f.symm.trans f = of_set {b | (f.symm b).is_some} :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.is_some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 132, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type u} {γ : Type v}, pequiv.{v u} α β → pequiv.{u v} β γ → pequiv.{v v} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} (s : set.{u} α) [_inst_2 : @decidable_pred.{u+1} α s], pequiv.{u u} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, (α → Prop) → set.{v} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  symm_injective $ by simp [symm_trans_rev, trans_symm, -symm_symm]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm_injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='pequiv.symm_trans_rev'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.trans_symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 79, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 165, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v}, @function.injective.{v+1 v+1} (pequiv.{v v} α β) (pequiv.{v v} β α) (@pequiv.symm.{v v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} (f : pequiv.{?l_1 ?l_2} α β) (g : pequiv.{?l_2 ?l_3} β γ), @eq.{(max (?l_3+1) (?l_1+1))} (pequiv.{?l_3 ?l_1} γ α) (@pequiv.symm.{?l_1 ?l_3} α γ (@pequiv.trans.{?l_1 ?l_2 ?l_3} α β γ f g)) (@pequiv.trans.{?l_3 ?l_2 ?l_1} γ β α (@pequiv.symm.{?l_2 ?l_3} β γ g) (@pequiv.symm.{?l_1 ?l_2} α β f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} (f : pequiv.{?l_1 ?l_2} α β), @eq.{?l_1+1} (pequiv.{?l_1 ?l_1} α α) (@pequiv.trans.{?l_1 ?l_2 ?l_1} α β α f (@pequiv.symm.{?l_1 ?l_2} α β f)) (@pequiv.of_set.{?l_1} α (@set_of.{?l_1} α (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{?l_2} β (@coe_fn.{(max (?l_1+1) (?l_2+1)) (max (?l_1+1) (?l_2+1))} (pequiv.{?l_1 ?l_2} α β) (@pequiv.has_coe_to_fun.{?l_1 ?l_2} α β) f a)))) (λ (a : α), @set.decidable_set_of.{?l_1} α (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{?l_2} β (@coe_fn.{(max (?l_1+1) (?l_2+1)) (max (?l_1+1) (?l_2+1))} (pequiv.{?l_1 ?l_2} α β) (@pequiv.has_coe_to_fun.{?l_1 ?l_2} α β) f a))) (λ (a : α), bool.decidable_eq (@option.is_some.{?l_2} β (@coe_fn.{(max (?l_1+1) (?l_2+1)) (max (?l_1+1) (?l_2+1))} (pequiv.{?l_1 ?l_2} α β) (@pequiv.has_coe_to_fun.{?l_1 ?l_2} α β) f a)) bool.tt) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ @eq.{v+1} (pequiv.{v v} β β)
    (@pequiv.symm.{v v} β β (@pequiv.trans.{v u v} β α β (@pequiv.symm.{u v} α β f) f))
    (@pequiv.symm.{v v} β β
       (@pequiv.of_set.{v} β
          (@set_of.{v} β
             (λ (b : β),
                @coe_sort.{1 1} bool coe_sort_bool
                  (@option.is_some.{u} α
                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                        (@pequiv.has_coe_to_fun.{v u} β α)
                        (@pequiv.symm.{u v} α β f)
                        b))))
          (λ (a : β),
             @set.decidable_set_of.{v} β
               (λ (b : β),
                  @coe_sort.{1 1} bool coe_sort_bool
                    (@option.is_some.{u} α
                       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                          (@pequiv.has_coe_to_fun.{v u} β α)
                          (@pequiv.symm.{u v} α β f)
                          b)))
               (λ (a : β),
                  bool.decidable_eq
                    (@option.is_some.{u} α
                       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                          (@pequiv.has_coe_to_fun.{v u} β α)
                          (@pequiv.symm.{u v} α β f)
                          a))
                    bool.tt)
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ @eq.{v+1} (pequiv.{v v} β β)
    (@pequiv.symm.{v v} β β (@pequiv.trans.{v u v} β α β (@pequiv.symm.{u v} α β f) f))
    (@pequiv.symm.{v v} β β
       (@pequiv.of_set.{v} β
          (@set_of.{v} β
             (λ (b : β),
                @coe_sort.{1 1} bool coe_sort_bool
                  (@option.is_some.{u} α
                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                        (@pequiv.has_coe_to_fun.{v u} β α)
                        (@pequiv.symm.{u v} α β f)
                        b))))
          (λ (a : β),
             @set.decidable_set_of.{v} β
               (λ (b : β),
                  @coe_sort.{1 1} bool coe_sort_bool
                    (@option.is_some.{u} α
                       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                          (@pequiv.has_coe_to_fun.{v u} β α)
                          (@pequiv.symm.{u v} α β f)
                          b)))
               (λ (a : β),
                  bool.decidable_eq
                    (@option.is_some.{u} α
                       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                          (@pequiv.has_coe_to_fun.{v u} β α)
                          (@pequiv.symm.{u v} α β f)
                          a))
                    bool.tt)
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  lemma trans_symm_eq_iff_forall_is_some {f : α ≃. β} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182    f.trans f.symm = pequiv.refl α ↔ ∀ a, is_some (f a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.is_some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type u}, pequiv.{u v} α β → pequiv.{v u} β γ → pequiv.{u u} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, option.{u} α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  by rw [trans_symm, of_set_eq_refl, set.eq_univ_iff_forall]; refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pequiv.trans_symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.of_set_eq_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.eq_univ_iff_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 167, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 154, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 248, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β), @eq.{u+1} (pequiv.{u u} α α) (@pequiv.trans.{u v u} α β α f (@pequiv.symm.{u v} α β f)) (@pequiv.of_set.{u} α (@set_of.{u} α (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{v} β (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)))) (λ (a : α), @set.decidable_set_of.{u} α (λ (a : α), @coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{v} β (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a))) (λ (a : α), bool.decidable_eq (@option.is_some.{v} β (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)) bool.tt) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α} [_inst_2 : @decidable_pred.{u+1} α s], iff (@eq.{u+1} (pequiv.{u u} α α) (@pequiv.of_set.{u} α s (λ (a : α), _inst_2 a)) (pequiv.refl.{u} α)) (@eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, iff (@eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α)) (∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ iff
    (@eq.{u+1} (pequiv.{u u} α α) (@pequiv.trans.{u v u} α β α f (@pequiv.symm.{u v} α β f))
       (pequiv.refl.{u} α))
    (∀ (a : α),
       @coe_sort.{1 1} bool coe_sort_bool
         (@option.is_some.{v} β
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ iff
    (@eq.{u+1} (pequiv.{u u} α α)
       (@pequiv.of_set.{u} α
          (@set_of.{u} α
             (λ (a : α),
                @coe_sort.{1 1} bool coe_sort_bool
                  (@option.is_some.{v} β
                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                        (@pequiv.has_coe_to_fun.{u v} α β)
                        f
                        a))))
          (λ (a : α),
             @set.decidable_set_of.{u} α
               (λ (a : α),
                  @coe_sort.{1 1} bool coe_sort_bool
                    (@option.is_some.{v} β
                       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                          (@pequiv.has_coe_to_fun.{u v} α β)
                          f
                          a)))
               (λ (a : α),
                  bool.decidable_eq
                    (@option.is_some.{v} β
                       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                          (@pequiv.has_coe_to_fun.{u v} α β)
                          f
                          a))
                    bool.tt)
               a))
       (pequiv.refl.{u} α))
    (∀ (a : α),
       @coe_sort.{1 1} bool coe_sort_bool
         (@option.is_some.{v} β
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ iff
    (@eq.{(max (u+1) 1)} (set.{u} α)
       (@set_of.{u} α
          (λ (a : α),
             @coe_sort.{1 1} bool coe_sort_bool
               (@option.is_some.{v} β
                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                     (@pequiv.has_coe_to_fun.{u v} α β)
                     f
                     a))))
       (@set.univ.{u} α))
    (∀ (a : α),
       @coe_sort.{1 1} bool coe_sort_bool
         (@option.is_some.{v} β
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ iff
    (∀ (x : α),
       @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
         (@set_of.{u} α
            (λ (a : α),
               @coe_sort.{1 1} bool coe_sort_bool
                 (@option.is_some.{v} β
                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                       (@pequiv.has_coe_to_fun.{u v} α β)
                       f
                       a)))))
    (∀ (a : α),
       @coe_sort.{1 1} bool coe_sort_bool
         (@option.is_some.{v} β
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ iff
    (@eq.{u+1} (pequiv.{u u} α α) (@pequiv.trans.{u v u} α β α f (@pequiv.symm.{u v} α β f))
       (pequiv.refl.{u} α))
    (∀ (a : α),
       @coe_sort.{1 1} bool coe_sort_bool
         (@option.is_some.{v} β
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β
⊢ iff
    (@eq.{u+1} (pequiv.{u u} α α) (@pequiv.trans.{u v u} α β α f (@pequiv.symm.{u v} α β f))
       (pequiv.refl.{u} α))
    (∀ (a : α),
       @coe_sort.{1 1} bool coe_sort_bool
         (@option.is_some.{v} β
            (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  instance : lattice.has_bot (α ≃. β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='lattice.has_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Typeclass for the `⊥` (`\bot`) notation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  ⟨{ to_fun := λ _, none,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187     inv_fun := λ _, none,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188     inv := by simp }⟩</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='lime'><a title='α : Type u,
β : Type v
⊢ ∀ (a : α) (b : β),
    iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (@option.none.{u} α))
      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@option.none.{v} β))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  @[simp] lemma bot_apply (a : α) : (⊥ : α ≃. β) a = none := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type (max u v)) [c : lattice.has_bot.{(max u v)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  @[simp] lemma symm_bot : (⊥ : α ≃. β).symm = ⊥ := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Π (α : Type (max u v)) [c : lattice.has_bot.{(max u v)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max v u)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type (max v u)) [c : lattice.has_bot.{(max v u)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type (max v u)} {a : α}, @eq.{(max (v+1) (u+1))} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  @[simp] lemma trans_bot (f : α ≃. β) : f.trans (⊥ : β ≃. γ) = ⊥ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type (max v w)) [c : lattice.has_bot.{(max v w)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type w → Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u w)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type (max u w)) [c : lattice.has_bot.{(max u w)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  by ext; dsimp [pequiv.trans]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3}, pequiv.{?l_1 ?l_2} α β → pequiv.{?l_2 ?l_3} β γ → pequiv.{?l_1 ?l_3} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
f : pequiv.{u v} α β
⊢ @eq.{(max (u+1) (w+1))} (pequiv.{u w} α γ)
    (@pequiv.trans.{u v w} α β γ f
       (@lattice.has_bot.bot.{(max v w)} (pequiv.{v w} β γ) (@pequiv.lattice.has_bot.{v w} β γ)))
    (@lattice.has_bot.bot.{(max u w)} (pequiv.{u w} α γ) (@pequiv.lattice.has_bot.{u w} α γ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
f : pequiv.{u v} α β
⊢ @eq.{(max (u+1) (w+1))} (pequiv.{u w} α γ)
    (@pequiv.trans.{u v w} α β γ f
       (@lattice.has_bot.bot.{(max v w)} (pequiv.{v w} β γ) (@pequiv.lattice.has_bot.{v w} β γ)))
    (@lattice.has_bot.bot.{(max u w)} (pequiv.{u w} α γ) (@pequiv.lattice.has_bot.{u w} α γ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  @[simp] lemma bot_trans (f : β ≃. γ) : (⊥ : α ≃. β).trans f = ⊥ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type w → Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type (max u v)) [c : lattice.has_bot.{(max u v)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u w)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type (max u w)) [c : lattice.has_bot.{(max u w)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  by ext; dsimp [pequiv.trans]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3}, pequiv.{?l_1 ?l_2} α β → pequiv.{?l_2 ?l_3} β γ → pequiv.{?l_1 ?l_3} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
f : pequiv.{v w} β γ
⊢ @eq.{(max (u+1) (w+1))} (pequiv.{u w} α γ)
    (@pequiv.trans.{u v w} α β γ
       (@lattice.has_bot.bot.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.has_bot.{u v} α β))
       f)
    (@lattice.has_bot.bot.{(max u w)} (pequiv.{u w} α γ) (@pequiv.lattice.has_bot.{u w} α γ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
f : pequiv.{v w} β γ
⊢ @eq.{(max (u+1) (w+1))} (pequiv.{u w} α γ)
    (@pequiv.trans.{u v w} α β γ
       (@lattice.has_bot.bot.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.has_bot.{u v} α β))
       f)
    (@lattice.has_bot.bot.{(max u w)} (pequiv.{u w} α γ) (@pequiv.lattice.has_bot.{u w} α γ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  lemma is_some_symm_get (f : α ≃. β) {a : α} (h : is_some (f a)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='option.is_some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u}, option.{u} α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201    is_some (f.symm (option.get h)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.is_some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.get'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/option/basic.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, option.{u} α → bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {o : option.{u} α}, @coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{u} α o) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{v} β (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  is_some_iff_exists.2 ⟨a, by rw [f.eq_some_iff, some_get]⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='option.is_some_iff_exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='option.some_get'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {x : option.{u} α}, iff (@coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{u} α x)) (@Exists.{u+1} α (λ (a : α), @eq.{u+1} (option.{u} α) x (@option.some.{u} α a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='iff (@eq.{u+1} (option.{u} α) (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α) (@pequiv.symm.{u v} α β f) (@option.get.{v} β (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) h)) (@option.some.{u} α a)) (@eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) (@option.some.{v} β (@option.get.{v} β (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) h)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {x : option.{v} α} (h : @coe_sort.{1 1} bool coe_sort_bool (@option.is_some.{v} α x)), @eq.{v+1} (option.{v} α) (@option.some.{v} α (@option.get.{v} α x h)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a : α,
h :
  @coe_sort.{1 1} bool coe_sort_bool
    (@option.is_some.{v} β
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a))
⊢ @eq.{u+1} (option.{u} α)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
       (@pequiv.symm.{u v} α β f)
       (@option.get.{v} β
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
          h))
    (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f : pequiv.{u v} α β,
a : α,
h :
  @coe_sort.{1 1} bool coe_sort_bool
    (@option.is_some.{v} β
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a))
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.some.{v} β
       (@option.get.{v} β
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204  section single</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  variables [decidable_eq α] [decidable_eq β] [decidable_eq γ]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type w → Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207  def single (a : α) (b : β) : α ≃. β :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  { to_fun := λ x, if x = a then some b else none,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209    inv_fun := λ x, if x = b then some a else none,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210    inv := λ _ _, by simp; split_ifs; cc }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1300, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Tries to prove the main goal using congruence closure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
a : α,
b : β,
_x : α,
_x : β
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) _x
       (@ite.{u+1} (@eq.{v+1} β _x b) (_inst_2 _x b) (option.{u} α) (@option.some.{u} α a) (@option.none.{u} α)))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) _x
       (@ite.{v+1} (@eq.{u+1} α _x a) (_inst_1 _x a) (option.{v} β) (@option.some.{v} β b) (@option.none.{v} β)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  lemma mem_single (a : α) (b : β) : b ∈ single a b a := if_pos rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type v} {t e : α}, @eq.{v+1} α (@ite.{v+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  lemma mem_single_iff (a₁ a₂ : α) (b₁ b₂ : β) : b₁ ∈ single a₂ b₂ a₁ ↔ a₁ = a₂ ∧ b₁ = b₂ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  by dsimp [single]; split_ifs; simp [*, eq_comm]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_eq.{?l_1+1} α] [_inst_2 : decidable_eq.{?l_2+1} β], α → β → pequiv.{?l_1 ?l_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {a b : α}, iff (@eq.{?l_1} α a b) (@eq.{?l_1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
a₁ a₂ : α,
b₁ b₂ : β
⊢ iff
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b₁
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
          (@pequiv.single.{u v} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a₂ b₂)
          a₁))
    (and (@eq.{u+1} α a₁ a₂) (@eq.{v+1} β b₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
a₁ a₂ : α,
b₁ b₂ : β
⊢ iff
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b₁
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
          (@pequiv.single.{u v} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a₂ b₂)
          a₁))
    (and (@eq.{u+1} α a₁ a₂) (@eq.{v+1} β b₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  @[simp] lemma symm_single (a : α) (b : β) : (single a b).symm = single b a := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max v u)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type (max v u)} {a : α}, @eq.{(max (v+1) (u+1))} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  @[simp] lemma single_apply (a : α) (b : β) : single a b a = some b := if_pos rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type v} {t e : α}, @eq.{v+1} α (@ite.{v+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  @[simp] lemma symm_single_apply (a : α) (b : β) : (single a b).symm b = some a := by dsimp; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                               </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                     </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                     </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                    </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
a : α,
b : β
⊢ @eq.{u+1} (option.{u} α)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
       (@pequiv.symm.{u v} α β
          (@pequiv.single.{u v} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a b))
       b)
    (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
a : α,
b : β
⊢ @eq.{u+1} (option.{u} α)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
       (@pequiv.symm.{u v} α β
          (@pequiv.single.{u v} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a b))
       b)
    (@option.some.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  lemma single_apply_of_ne {a₁ a₂ : α} (h : a₁ ≠ a₂) (b : β) : single a₁ b a₂ = none := if_neg h.symm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ne.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type v} {t e : α}, @eq.{v+1} α (@ite.{v+1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u+1} α a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, @ne.{u+1} α a b → @ne.{u+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  lemma single_trans_of_mem (a : α) {b : β} {c : γ} {f : β ≃. γ} (h : c ∈ f b) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type w → Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type w} [c : has_mem.{w w} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226    (single a b).trans f = single a c :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u w)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
a : α,
b : β,
c : γ,
f : pequiv.{v w} β γ,
h :
  @has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) c
    (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ) f b)
⊢ @eq.{(max (u+1) (w+1))} (pequiv.{u w} α γ)
    (@pequiv.trans.{u v w} α β γ
       (@pequiv.single.{u v} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a b)
       f)
    (@pequiv.single.{u w} α γ (λ (a b : α), _inst_1 a b) (λ (a b : γ), _inst_3 a b) a c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228    ext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
a : α,
b : β,
c : γ,
f : pequiv.{v w} β γ,
h :
  @has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) c
    (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ) f b)
⊢ @eq.{(max (u+1) (w+1))} (pequiv.{u w} α γ)
    (@pequiv.trans.{u v w} α β γ
       (@pequiv.single.{u v} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a b)
       f)
    (@pequiv.single.{u w} α γ (λ (a b : α), _inst_1 a b) (λ (a b : γ), _inst_3 a b) a c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
a : α,
b : β,
c : γ,
f : pequiv.{v w} β γ,
h :
  @has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) c
    (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ) f b),
x : α,
a_1 : γ
⊢ iff
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a_1
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@pequiv.trans.{u v w} α β γ
             (@pequiv.single.{u v} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a b)
             f)
          x))
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a_1
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@pequiv.single.{u w} α γ (λ (a b : α), _inst_1 a b) (λ (a b : γ), _inst_3 a b) a c)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229    dsimp [single, pequiv.trans],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_eq.{?l_1+1} α] [_inst_2 : decidable_eq.{?l_2+1} β], α → β → pequiv.{?l_1 ?l_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3}, pequiv.{?l_1 ?l_2} α β → pequiv.{?l_2 ?l_3} β γ → pequiv.{?l_1 ?l_3} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
a : α,
b : β,
c : γ,
f : pequiv.{v w} β γ,
h :
  @has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) c
    (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ) f b),
x : α,
a_1 : γ
⊢ iff
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a_1
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@pequiv.trans.{u v w} α β γ
             (@pequiv.single.{u v} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a b)
             f)
          x))
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a_1
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@pequiv.single.{u w} α γ (λ (a b : α), _inst_1 a b) (λ (a b : γ), _inst_3 a b) a c)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
a : α,
b : β,
c : γ,
f : pequiv.{v w} β γ,
h :
  @has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) c
    (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ) f b),
x : α,
a_1 : γ
⊢ iff
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a_1
       (@option.bind.{v w} β γ
          (@ite.{v+1} (@eq.{u+1} α x a) (_inst_1 x a) (option.{v} β) (@option.some.{v} β b) (@option.none.{v} β))
          (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ) f)))
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a_1
       (@ite.{w+1} (@eq.{u+1} α x a) (_inst_1 x a) (option.{w} γ) (@option.some.{w} γ c) (@option.none.{w} γ)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230    split_ifs; simp * at *</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
a : α,
b : β,
c : γ,
f : pequiv.{v w} β γ,
h :
  @has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) c
    (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ) f b),
x : α,
a_1 : γ
⊢ iff
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a_1
       (@option.bind.{v w} β γ
          (@ite.{v+1} (@eq.{u+1} α x a) (_inst_1 x a) (option.{v} β) (@option.some.{v} β b) (@option.none.{v} β))
          (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ) f)))
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a_1
       (@ite.{w+1} (@eq.{u+1} α x a) (_inst_1 x a) (option.{w} γ) (@option.some.{w} γ c) (@option.none.{w} γ)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  lemma trans_single_of_mem {a : α} {b : β} (c : γ) {f : α ≃. β} (h : b ∈ f a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234    f.trans (single b c) = single a c :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u w)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  symm_injective $ single_trans_of_mem _ ((mem_iff_mem f).2 h)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm_injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pequiv.single_trans_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pequiv.mem_iff_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 79, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 225, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 59, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type w}, @function.injective.{(max (u+1) (w+1)) (max (w+1) (u+1))} (pequiv.{u w} α β) (pequiv.{w u} β α) (@pequiv.symm.{u w} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type w} {β : Type v} {γ : Type u} [_inst_1 : decidable_eq.{w+1} α] [_inst_2 : decidable_eq.{v+1} β] [_inst_3 : decidable_eq.{u+1} γ] (a : α) {b : β} {c : γ} {f : pequiv.{v u} β γ}, @has_mem.mem.{u u} γ (option.{u} γ) (@option.has_mem.{u} γ) c (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β γ) (@pequiv.has_coe_to_fun.{v u} β γ) f b) → @eq.{(max (w+1) (u+1))} (pequiv.{w u} α γ) (@pequiv.trans.{w v u} α β γ (@pequiv.single.{w v} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a b) f) (@pequiv.single.{w u} α γ (λ (a b : α), _inst_1 a b) (λ (a b : γ), _inst_3 a b) a c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β) {a : α} {b : β}, iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α) (@pequiv.symm.{u v} α β f) b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  @[simp] lemma single_trans_single (a : α) (b : β) (c : γ) : (single a b).trans (single b c) = single a c :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u w)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  single_trans_of_mem _ (mem_single _ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.single_trans_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv.mem_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 225, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type w} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β] [_inst_3 : decidable_eq.{w+1} γ] (a : α) {b : β} {c : γ} {f : pequiv.{v w} β γ}, @has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) c (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ) f b) → @eq.{(max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.trans.{u v w} α β γ (@pequiv.single.{u v} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a b) f) (@pequiv.single.{u w} α γ (λ (a b : α), _inst_1 a b) (λ (a b : γ), _inst_3 a b) a c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {β : Type w} [_inst_1 : decidable_eq.{v+1} α] [_inst_2 : decidable_eq.{w+1} β] (a : α) (b : β), @has_mem.mem.{w w} β (option.{w} β) (@option.has_mem.{w} β) b (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} α β) (@pequiv.has_coe_to_fun.{v w} α β) (@pequiv.single.{v w} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a b) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  @[simp] lemma single_subsingleton_eq_refl [subsingleton α] (a b : α) : single a b = pequiv.refl α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='subsingleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 804, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : decidable_eq.{u+1} α,
_inst_4 : subsingleton.{u+1} α,
a b : α
⊢ @eq.{u+1} (pequiv.{u u} α α)
    (@pequiv.single.{u u} α α (λ (a b : α), _inst_1 a b) (λ (a b : α), _inst_1 a b) a b)
    (pequiv.refl.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242    ext i j,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : decidable_eq.{u+1} α,
_inst_4 : subsingleton.{u+1} α,
a b : α
⊢ @eq.{u+1} (pequiv.{u u} α α)
    (@pequiv.single.{u u} α α (λ (a b : α), _inst_1 a b) (λ (a b : α), _inst_1 a b) a b)
    (pequiv.refl.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : decidable_eq.{u+1} α,
_inst_4 : subsingleton.{u+1} α,
a b i j : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
          (@pequiv.single.{u u} α α (λ (a b : α), _inst_1 a b) (λ (a b : α), _inst_1 a b) a b)
          i))
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α) (pequiv.refl.{u} α) i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243    dsimp [single],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_eq.{?l_1+1} α] [_inst_2 : decidable_eq.{?l_2+1} β], α → β → pequiv.{?l_1 ?l_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : decidable_eq.{u+1} α,
_inst_4 : subsingleton.{u+1} α,
a b i j : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α)
          (@pequiv.single.{u u} α α (λ (a b : α), _inst_1 a b) (λ (a b : α), _inst_1 a b) a b)
          i))
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j
       (@coe_fn.{u+1 u+1} (pequiv.{u u} α α) (@pequiv.has_coe_to_fun.{u u} α α) (pequiv.refl.{u} α) i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : decidable_eq.{u+1} α,
_inst_4 : subsingleton.{u+1} α,
a b i j : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j
       (@ite.{u+1} (@eq.{u+1} α i a) (_inst_1 i a) (option.{u} α) (@option.some.{u} α b) (@option.none.{u} α)))
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j (@option.some.{u} α i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244    rw [if_pos (subsingleton.elim i a), subsingleton.elim i j, subsingleton.elim b j]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subsingleton.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='subsingleton.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subsingleton.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 807, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 807, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 807, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u} {t e : α}, @eq.{u+1} α (@ite.{u+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [h : subsingleton.{u+1} α] (a b : α), @eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [h : subsingleton.{u+1} α] (a b : α), @eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [h : subsingleton.{u+1} α] (a b : α), @eq.{u+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : decidable_eq.{u+1} α,
_inst_4 : subsingleton.{u+1} α,
a b i j : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j
       (@ite.{u+1} (@eq.{u+1} α i a) (_inst_1 i a) (option.{u} α) (@option.some.{u} α b) (@option.none.{u} α)))
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j (@option.some.{u} α i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : decidable_eq.{u+1} α,
_inst_4 : subsingleton.{u+1} α,
a b i j : α
⊢ iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j (@option.some.{u} α b))
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j (@option.some.{u} α i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : decidable_eq.{u+1} α,
_inst_4 : subsingleton.{u+1} α,
a b i j : α
⊢ iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j (@option.some.{u} α b))
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j (@option.some.{u} α j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : decidable_eq.{u+1} α,
_inst_4 : subsingleton.{u+1} α,
a b i j : α
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j
       (@ite.{u+1} (@eq.{u+1} α i a) (_inst_1 i a) (option.{u} α) (@option.some.{u} α b) (@option.none.{u} α)))
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) j (@option.some.{u} α i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  lemma trans_single_of_eq_none {b : β} (c : γ) {f : α ≃. β} (h : f.symm b = none) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248    f.trans (single b c) = ⊥ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u w)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type (max u w)) [c : lattice.has_bot.{(max u w)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
h :
  @eq.{u+1} (option.{u} α)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
       (@pequiv.symm.{u v} α β f)
       b)
    (@option.none.{u} α)
⊢ @eq.{(max (u+1) (w+1))} (pequiv.{u w} α γ)
    (@pequiv.trans.{u v w} α β γ f
       (@pequiv.single.{v w} β γ (λ (a b : β), _inst_2 a b) (λ (a b : γ), _inst_3 a b) b c))
    (@lattice.has_bot.bot.{(max u w)} (pequiv.{u w} α γ) (@pequiv.lattice.has_bot.{u w} α γ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250    ext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
h :
  @eq.{u+1} (option.{u} α)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
       (@pequiv.symm.{u v} α β f)
       b)
    (@option.none.{u} α)
⊢ @eq.{(max (u+1) (w+1))} (pequiv.{u w} α γ)
    (@pequiv.trans.{u v w} α β γ f
       (@pequiv.single.{v w} β γ (λ (a b : β), _inst_2 a b) (λ (a b : γ), _inst_3 a b) b c))
    (@lattice.has_bot.bot.{(max u w)} (pequiv.{u w} α γ) (@pequiv.lattice.has_bot.{u w} α γ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
h :
  @eq.{u+1} (option.{u} α)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
       (@pequiv.symm.{u v} α β f)
       b)
    (@option.none.{u} α),
x : α,
a : γ
⊢ iff
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@pequiv.trans.{u v w} α β γ f
             (@pequiv.single.{v w} β γ (λ (a b : β), _inst_2 a b) (λ (a b : γ), _inst_3 a b) b c))
          x))
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@lattice.has_bot.bot.{(max u w)} (pequiv.{u w} α γ) (@pequiv.lattice.has_bot.{u w} α γ))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251    simp only [eq_none_iff_forall_not_mem, option.mem_def, f.eq_some_iff] at h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='option.eq_none_iff_forall_not_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.mem_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/defs.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {o : option.{?l_1} α}, iff (@eq.{?l_1+1} (option.{?l_1} α) o (@option.none.{?l_1} α)) (∀ (a : α), not (@has_mem.mem.{?l_1 ?l_1} α (option.{?l_1} α) (@option.has_mem.{?l_1} α) a o))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {b : option.{?l_1} α}, iff (@has_mem.mem.{?l_1 ?l_1} α (option.{?l_1} α) (@option.has_mem.{?l_1} α) a b) (@eq.{?l_1+1} (option.{?l_1} α) b (@option.some.{?l_1} α a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='iff (@eq.{u+1} (option.{u} α) (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α) (@pequiv.symm.{u v} α β f) ?m_1) (@option.some.{u} α ?m_2)) (@eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f ?m_2) (@option.some.{v} β ?m_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
h :
  @eq.{u+1} (option.{u} α)
    (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
       (@pequiv.symm.{u v} α β f)
       b)
    (@option.none.{u} α),
x : α,
a : γ
⊢ iff
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@pequiv.trans.{u v w} α β γ f
             (@pequiv.single.{v w} β γ (λ (a b : β), _inst_2 a b) (λ (a b : γ), _inst_3 a b) b c))
          x))
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@lattice.has_bot.bot.{(max u w)} (pequiv.{u w} α γ) (@pequiv.lattice.has_bot.{u w} α γ))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
x : α,
a : γ,
h :
  ∀ (a : α),
    not
      (@eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
         (@option.some.{v} β b))
⊢ iff
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@pequiv.trans.{u v w} α β γ f
             (@pequiv.single.{v w} β γ (λ (a b : β), _inst_2 a b) (λ (a b : γ), _inst_3 a b) b c))
          x))
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@lattice.has_bot.bot.{(max u w)} (pequiv.{u w} α γ) (@pequiv.lattice.has_bot.{u w} α γ))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252    dsimp [pequiv.trans, single],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3}, pequiv.{?l_1 ?l_2} α β → pequiv.{?l_2 ?l_3} β γ → pequiv.{?l_1 ?l_3} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_eq.{?l_1+1} α] [_inst_2 : decidable_eq.{?l_2+1} β], α → β → pequiv.{?l_1 ?l_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
x : α,
a : γ,
h :
  ∀ (a : α),
    not
      (@eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
         (@option.some.{v} β b))
⊢ iff
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@pequiv.trans.{u v w} α β γ f
             (@pequiv.single.{v w} β γ (λ (a b : β), _inst_2 a b) (λ (a b : γ), _inst_3 a b) b c))
          x))
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a
       (@coe_fn.{(max (u+1) (w+1)) (max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.has_coe_to_fun.{u w} α γ)
          (@lattice.has_bot.bot.{(max u w)} (pequiv.{u w} α γ) (@pequiv.lattice.has_bot.{u w} α γ))
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
x : α,
a : γ,
h :
  ∀ (a : α),
    not
      (@eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
         (@option.some.{v} β b))
⊢ iff
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a
       (@option.bind.{v w} β γ
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
          (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ)
             (@pequiv.mk.{v w} β γ
                (λ (x : β),
                   @ite.{w+1} (@eq.{v+1} β x b) (_inst_2 x b) (option.{w} γ) (@option.some.{w} γ c)
                     (@option.none.{w} γ))
                (λ (x : γ),
                   @ite.{v+1} (@eq.{w+1} γ x c) (_inst_3 x c) (option.{v} β) (@option.some.{v} β b)
                     (@option.none.{v} β))
                (@pequiv.single._proof_1.{v w} β γ _inst_2 _inst_3 b c)))))
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a (@option.none.{w} γ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253    simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
x : α,
a : γ,
h :
  ∀ (a : α),
    not
      (@eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
         (@option.some.{v} β b))
⊢ iff
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a
       (@option.bind.{v w} β γ
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
          (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ)
             (@pequiv.mk.{v w} β γ
                (λ (x : β),
                   @ite.{w+1} (@eq.{v+1} β x b) (_inst_2 x b) (option.{w} γ) (@option.some.{w} γ c)
                     (@option.none.{w} γ))
                (λ (x : γ),
                   @ite.{v+1} (@eq.{w+1} γ x c) (_inst_3 x c) (option.{v} β) (@option.some.{v} β b)
                     (@option.none.{v} β))
                (@pequiv.single._proof_1.{v w} β γ _inst_2 _inst_3 b c)))))
    (@has_mem.mem.{w w} γ (option.{w} γ) (@option.has_mem.{w} γ) a (@option.none.{w} γ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
x : α,
a : γ,
h :
  ∀ (a : α),
    not
      (@eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
         (@option.some.{v} β b))
⊢ ∀ (x_1 : β),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
      (@option.some.{v} β x_1) →
    not
      (@eq.{w+1} (option.{w} γ)
         (@ite.{w+1} (@eq.{v+1} β x_1 b) (_inst_2 x_1 b) (option.{w} γ) (@option.some.{w} γ c) (@option.none.{w} γ))
         (@option.some.{w} γ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254    intros,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
x : α,
a : γ,
h :
  ∀ (a : α),
    not
      (@eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
         (@option.some.{v} β b))
⊢ ∀ (x_1 : β),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
      (@option.some.{v} β x_1) →
    not
      (@eq.{w+1} (option.{w} γ)
         (@ite.{w+1} (@eq.{v+1} β x_1 b) (_inst_2 x_1 b) (option.{w} γ) (@option.some.{w} γ c) (@option.none.{w} γ))
         (@option.some.{w} γ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
x : α,
a : γ,
h :
  ∀ (a : α),
    not
      (@eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
         (@option.some.{v} β b)),
x_1 : β,
a_1 :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.some.{v} β x_1)
⊢ not
    (@eq.{w+1} (option.{w} γ)
       (@ite.{w+1} (@eq.{v+1} β x_1 b) (_inst_2 x_1 b) (option.{w} γ) (@option.some.{w} γ c) (@option.none.{w} γ))
       (@option.some.{w} γ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255    split_ifs;</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
x : α,
a : γ,
h :
  ∀ (a : α),
    not
      (@eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
         (@option.some.{v} β b)),
x_1 : β,
a_1 :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.some.{v} β x_1)
⊢ not
    (@eq.{w+1} (option.{w} γ)
       (@ite.{w+1} (@eq.{v+1} β x_1 b) (_inst_2 x_1 b) (option.{w} γ) (@option.some.{w} γ c) (@option.none.{w} γ))
       (@option.some.{w} γ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256    simp * at *</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
γ : Type w,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_inst_3 : decidable_eq.{w+1} γ,
b : β,
c : γ,
f : pequiv.{u v} α β,
x : α,
a : γ,
h :
  ∀ (a : α),
    not
      (@eq.{v+1} (option.{v} β)
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
         (@option.some.{v} β b)),
x_1 : β,
a_1 :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
    (@option.some.{v} β x_1)
⊢ not
    (@eq.{w+1} (option.{w} γ)
       (@ite.{w+1} (@eq.{v+1} β x_1 b) (_inst_2 x_1 b) (option.{w} γ) (@option.some.{w} γ c) (@option.none.{w} γ))
       (@option.some.{w} γ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  lemma single_trans_of_eq_none (a : α) {b : β} {f : β ≃. γ} (h : f b = none) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type w → Type (max v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type w}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260    (single a b).trans f = ⊥ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='pequiv.{v w} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u w)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type (max u w)) [c : lattice.has_bot.{(max u w)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  symm_injective $ trans_single_of_eq_none _ h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm_injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pequiv.trans_single_of_eq_none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 79, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 247, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type w}, @function.injective.{(max (u+1) (w+1)) (max (w+1) (u+1))} (pequiv.{u w} α β) (pequiv.{w u} β α) (@pequiv.symm.{u w} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type w} {β : Type v} {γ : Type u} [_inst_1 : decidable_eq.{w+1} α] [_inst_2 : decidable_eq.{v+1} β] [_inst_3 : decidable_eq.{u+1} γ] {b : β} (c : γ) {f : pequiv.{w v} α β}, @eq.{w+1} (option.{w} α) (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β α) (@pequiv.has_coe_to_fun.{v w} β α) (@pequiv.symm.{w v} α β f) b) (@option.none.{w} α) → @eq.{(max (w+1) (u+1))} (pequiv.{w u} α γ) (@pequiv.trans.{w v u} α β γ f (@pequiv.single.{v u} β γ (λ (a b : β), _inst_2 a b) (λ (a b : γ), _inst_3 a b) b c)) (@lattice.has_bot.bot.{(max w u)} (pequiv.{w u} α γ) (@pequiv.lattice.has_bot.{w u} α γ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@eq.{w+1} (option.{w} γ) (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ) f b) (@option.none.{w} γ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263  lemma single_trans_single_of_ne {b₁ b₂ : β} (h : b₁ ≠ b₂) (a : α) (c : γ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264    (single a b₁).trans (single b₂ c) = ⊥ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='pequiv.single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 207, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} {γ : Type w}, pequiv.{u v} α β → pequiv.{v w} β γ → pequiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β], α → β → pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u w)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type (max u w)) [c : lattice.has_bot.{(max u w)} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265  single_trans_of_eq_none _ (single_apply_of_ne h.symm _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.single_trans_of_eq_none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv.single_apply_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ne.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 259, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 223, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type w} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : decidable_eq.{v+1} β] [_inst_3 : decidable_eq.{w+1} γ] (a : α) {b : β} {f : pequiv.{v w} β γ}, @eq.{w+1} (option.{w} γ) (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} β γ) (@pequiv.has_coe_to_fun.{v w} β γ) f b) (@option.none.{w} γ) → @eq.{(max (u+1) (w+1))} (pequiv.{u w} α γ) (@pequiv.trans.{u v w} α β γ (@pequiv.single.{u v} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a b) f) (@lattice.has_bot.bot.{(max u w)} (pequiv.{u w} α γ) (@pequiv.lattice.has_bot.{u w} α γ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v} {β : Type w} [_inst_1 : decidable_eq.{v+1} α] [_inst_2 : decidable_eq.{w+1} β] {a₁ a₂ : α}, @ne.{v+1} α a₁ a₂ → ∀ (b : β), @eq.{w+1} (option.{w} β) (@coe_fn.{(max (v+1) (w+1)) (max (v+1) (w+1))} (pequiv.{v w} α β) (@pequiv.has_coe_to_fun.{v w} α β) (@pequiv.single.{v w} α β (λ (a b : α), _inst_1 a b) (λ (a b : β), _inst_2 a b) a₁ b) a₂) (@option.none.{w} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{v+1} β b₁ b₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {a b : α}, @ne.{v+1} α a b → @ne.{v+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  end single</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  section order</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  open lattice</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  instance : partial_order (α ≃. β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  { le := λ f g, ∀ (a : α) (b : β), b ∈ f a → b ∈ g a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='order_laws_tac'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 1296, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274    le_refl := λ _ _ _, id,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275    le_trans := λ f g h fg gh a b, (gh a b) ∘ (fg a b),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='gh'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='gh'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{(max u v)} (pequiv.{u v} α β) (@has_le.mk.{(max u v)} (pequiv.{u v} α β) (λ (f g : pequiv.{u v} α β), ∀ (a : α) (b : β), @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) → @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{(max u v)} (pequiv.{u v} α β) (@has_le.mk.{(max u v)} (pequiv.{u v} α β) (λ (f g : pequiv.{u v} α β), ∀ (a : α) (b : β), @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) → @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))) g h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_le.le.{(max u v)} (pequiv.{u v} α β) (@has_le.mk.{(max u v)} (pequiv.{u v} α β) (λ (f g : pequiv.{u v} α β), ∀ (a : α) (b : β), @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) → @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))) g h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β φ : Prop}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_le.le.{(max u v)} (pequiv.{u v} α β) (@has_le.mk.{(max u v)} (pequiv.{u v} α β) (λ (f g : pequiv.{u v} α β), ∀ (a : α) (b : β), @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) → @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276    le_antisymm := λ f g fg gf, ext begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='gf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 29, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(λ (f g : pequiv.{u v} α β), ∀ (a : α) (b : β), @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) → @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(λ (f g : pequiv.{u v} α β), ∀ (a : α) (b : β), @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) → @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)) g f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {f g : pequiv.{u v} α β}, (∀ (x : α), @eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g x)) → @eq.{(max (u+1) (v+1))} (pequiv.{u v} α β) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='α : Type u,
β : Type v,
f g : pequiv.{u v} α β,
fg :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    f
    g,
gf :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    g
    f
⊢ ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277      assume a,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f g : pequiv.{u v} α β,
fg :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    f
    g,
gf :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    g
    f
⊢ ∀ (x : α),
    @eq.{v+1} (option.{v} β)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f x)
      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f g : pequiv.{u v} α β,
fg :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    f
    g,
gf :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    g
    f,
a : α
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278      cases h : g a with b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
f g : pequiv.{u v} α β,
fg :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    f
    g,
gf :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    g
    f,
a : α
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u,
β : Type v,
f g : pequiv.{u v} α β,
fg :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    f
    g,
gf :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    g
    f,
a : α,
h :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
    (@option.none.{v} β)
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.none.{v} β)

case option.some
α : Type u,
β : Type v,
f g : pequiv.{u v} α β,
fg :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    f
    g,
gf :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    g
    f,
a : α,
b : β,
h :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
    (@option.some.{v} β b)
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.some.{v} β b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279      { exact eq_none_iff_forall_not_mem.2</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='option.eq_none_iff_forall_not_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {o : option.{v} α}, iff (@eq.{v+1} (option.{v} α) o (@option.none.{v} α)) (∀ (a : α), not (@has_mem.mem.{v v} α (option.{v} α) (@option.has_mem.{v} α) a o))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u,
β : Type v,
f g : pequiv.{u v} α β,
fg :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    f
    g,
gf :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    g
    f,
a : α,
h :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
    (@option.none.{v} β)
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.none.{v} β)

case option.some
α : Type u,
β : Type v,
f g : pequiv.{u v} α β,
fg :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    f
    g,
gf :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    g
    f,
a : α,
b : β,
h :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
    (@option.some.{v} β b)
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.some.{v} β b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u,
β : Type v,
f g : pequiv.{u v} α β,
fg :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    f
    g,
gf :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    g
    f,
a : α,
h :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
    (@option.none.{v} β)
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.none.{v} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280         (λ b hb, option.not_mem_none b $ h ▸ fg a b hb) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='option.not_mem_none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} (a : α), not (@has_mem.mem.{v v} α (option.{v} α) (@option.has_mem.{v} α) a (@option.none.{v} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a) (@option.none.{v} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {P : α → Prop} {a b : α}, @eq.{v+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='(λ (f g : pequiv.{u v} α β), ∀ (a : α) (b : β), @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) → @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u,
β : Type v,
f g : pequiv.{u v} α β,
fg :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    f
    g,
gf :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    g
    f,
a : α,
h :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
    (@option.none.{v} β)
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.none.{v} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u,
β : Type v,
f g : pequiv.{u v} α β,
fg :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    f
    g,
gf :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    g
    f,
a : α,
b : β,
h :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
    (@option.some.{v} β b)
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.some.{v} β b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281      { exact gf _ _ h }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='gf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='(λ (f g : pequiv.{u v} α β), ∀ (a : α) (b : β), @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) → @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)) g f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} (option.{v} β) (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a) (@option.some.{v} β b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u,
β : Type v,
f g : pequiv.{u v} α β,
fg :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    f
    g,
gf :
  (λ (f g : pequiv.{u v} α β),
     ∀ (a : α) (b : β),
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
            a) →
       @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
    g
    f,
a : α,
b : β,
h :
  @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
    (@option.some.{v} β b)
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.some.{v} β b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  lemma le_def {f g : α ≃. β} : f ≤ g ↔ (∀ (a : α) (b : β), b ∈ f a → b ∈ g a) := iff.rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='iff.rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 244, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)} [c : has_le.{(max u v)} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type v} [c : has_mem.{v v} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {a : Prop}, iff a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286  instance : order_bot (α ≃. β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='lattice.order_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An `order_bot` is a partial order with a minimal element.
 (We could state this on preorders, but then it wouldn&#x27;t be unique
 so distinguishing one would seem odd.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287  { bot_le := λ _ _  _ h, (not_mem_none _ h).elim,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='option.not_mem_none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='false.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) _x (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) (@lattice.has_bot.bot.{(max u v)} (pequiv.{u v} α β) (@lattice.has_bot.mk.{(max u v)} (pequiv.{u v} α β) (@lattice.has_bot.bot.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.has_bot.{u v} α β)))) _x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} (a : α), not (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a (@option.none.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) _x (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) (@lattice.has_bot.bot.{(max u v)} (pequiv.{u v} α β) (@lattice.has_bot.mk.{(max u v)} (pequiv.{u v} α β) (@lattice.has_bot.bot.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.has_bot.{u v} α β)))) _x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {C : Prop}, false → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288    ..pequiv.partial_order,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv.partial_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v}, partial_order.{(max u v)} (pequiv.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289    ..pequiv.lattice.has_bot }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv.lattice.has_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 185, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v}, lattice.has_bot.{(max u v)} (pequiv.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291  instance [decidable_eq α] [decidable_eq β] : semilattice_inf_bot (α ≃. β) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lattice.semilattice_inf_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 222, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='A `semilattice_inf_bot` is a semilattice with bottom and meet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292  { inf := λ f g,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293    { to_fun := λ a, if f a = g a then f a else none,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294      inv_fun := λ b, if f.symm b = g.symm b then f.symm b else none,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, pequiv.{u v} α β → pequiv.{v u} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295      inv := λ a b, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g : pequiv.{u v} α β,
a : α,
b : β
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@ite.{u+1}
          (@eq.{u+1} (option.{u} α)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (option.{u} α)
          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
             (@pequiv.symm.{u v} α β f)
             b)
          (@option.none.{u} α)))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@ite.{v+1}
          (@eq.{v+1} (option.{v} β)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (option.{v} β)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
          (@option.none.{v} β)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296        have := @mem_iff_mem _ _ f a b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pequiv.mem_iff_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 59, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β) {a : α} {b : β}, iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α) (@pequiv.symm.{u v} α β f) b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g : pequiv.{u v} α β,
a : α,
b : β
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@ite.{u+1}
          (@eq.{u+1} (option.{u} α)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (option.{u} α)
          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
             (@pequiv.symm.{u v} α β f)
             b)
          (@option.none.{u} α)))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@ite.{v+1}
          (@eq.{v+1} (option.{v} β)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (option.{v} β)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
          (@option.none.{v} β)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g : pequiv.{u v} α β,
a : α,
b : β,
this :
  iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
          (@pequiv.symm.{u v} α β f)
          b))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a))
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@ite.{u+1}
          (@eq.{u+1} (option.{u} α)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (option.{u} α)
          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
             (@pequiv.symm.{u v} α β f)
             b)
          (@option.none.{u} α)))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@ite.{v+1}
          (@eq.{v+1} (option.{v} β)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (option.{v} β)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
          (@option.none.{v} β)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297        have := @mem_iff_mem _ _ g a b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='pequiv.mem_iff_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 59, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} (f : pequiv.{u v} α β) {a : α} {b : β}, iff (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α) (@pequiv.symm.{u v} α β f) b)) (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g : pequiv.{u v} α β,
a : α,
b : β,
this :
  iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
          (@pequiv.symm.{u v} α β f)
          b))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a))
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@ite.{u+1}
          (@eq.{u+1} (option.{u} α)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (option.{u} α)
          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
             (@pequiv.symm.{u v} α β f)
             b)
          (@option.none.{u} α)))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@ite.{v+1}
          (@eq.{v+1} (option.{v} β)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (option.{v} β)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
          (@option.none.{v} β)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g : pequiv.{u v} α β,
a : α,
b : β,
this :
  iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
          (@pequiv.symm.{u v} α β f)
          b))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)),
this :
  iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
          (@pequiv.symm.{u v} α β g)
          b))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@ite.{u+1}
          (@eq.{u+1} (option.{u} α)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (option.{u} α)
          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
             (@pequiv.symm.{u v} α β f)
             b)
          (@option.none.{u} α)))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@ite.{v+1}
          (@eq.{v+1} (option.{v} β)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (option.{v} β)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
          (@option.none.{v} β)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298        split_ifs; finish</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g : pequiv.{u v} α β,
a : α,
b : β,
this :
  iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
          (@pequiv.symm.{u v} α β f)
          b))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)),
this :
  iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
          (@pequiv.symm.{u v} α β g)
          b))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@ite.{u+1}
          (@eq.{u+1} (option.{u} α)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (option.{u} α)
          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
             (@pequiv.symm.{u v} α β f)
             b)
          (@option.none.{u} α)))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@ite.{v+1}
          (@eq.{v+1} (option.{v} β)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (option.{v} β)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
          (@option.none.{v} β)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299      end },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g : pequiv.{u v} α β,
a : α,
b : β,
this :
  iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
          (@pequiv.symm.{u v} α β f)
          b))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)),
this :
  iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
          (@pequiv.symm.{u v} α β g)
          b))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a))
⊢ iff
    (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
       (@ite.{u+1}
          (@eq.{u+1} (option.{u} α)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β f)
                b)
             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
                (@pequiv.symm.{u v} α β g)
                b))
          (option.{u} α)
          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α) (@pequiv.has_coe_to_fun.{v u} β α)
             (@pequiv.symm.{u v} α β f)
             b)
          (@option.none.{u} α)))
    (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
       (@ite.{v+1}
          (@eq.{v+1} (option.{v} β)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f
                a)
             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g
                a))
          (option.{v} β)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
          (@option.none.{v} β)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300    inf_le_left := λ _ _ _ _, by simp; split_ifs; cc,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1300, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Tries to prove the main goal using congruence closure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_x _x : pequiv.{u v} α β,
_x : α,
_x : β
⊢ @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) _x
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@lattice.has_inf.inf.{(max u v)} (pequiv.{u v} α β)
          (@lattice.has_inf.mk.{(max u v)} (pequiv.{u v} α β)
             (λ (f g : pequiv.{u v} α β),
                @pequiv.mk.{u v} α β
                  (λ (a : α),
                     @ite.{v+1}
                       (@eq.{v+1} (option.{v} β)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (option.{v} β)
                       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                          (@pequiv.has_coe_to_fun.{u v} α β)
                          f
                          a)
                       (@option.none.{v} β))
                  (λ (b : β),
                     @ite.{u+1}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (option.{u} α)
                       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                          (@pequiv.has_coe_to_fun.{v u} β α)
                          (@pequiv.symm.{u v} α β f)
                          b)
                       (@option.none.{u} α))
                  (λ (a : α) (b : β),
                     @dite.{0}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (iff
                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                             (@ite.{u+1}
                                (@eq.{u+1} (option.{u} α)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (option.{u} α)
                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                   (@pequiv.symm.{u v} α β f)
                                   b)
                                (@option.none.{u} α)))
                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                             (@ite.{v+1}
                                (@eq.{v+1} (option.{v} β)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (option.{v} β)
                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                   f
                                   a)
                                (@option.none.{v} β))))
                       (λ
                        (h :
                          @eq.{u+1} (option.{u} α)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β f)
                               b)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β g)
                               b)),
                          @eq.mpr.{0}
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@ite.{u+1}
                                     (@eq.{u+1} (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (option.{u} α)
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@option.none.{u} α)))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                     (@pequiv.has_coe_to_fun.{v u} β α)
                                     (@pequiv.symm.{u v} α β f)
                                     b))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (@id.{0}
                               (@eq.{1} Prop
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@ite.{u+1}
                                           (@eq.{u+1} (option.{u} α)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@option.none.{u} α)))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β)))))
                               ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop) (e_2 : @eq.{1} Prop b b_1),
                                   @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                     (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                     e_2)
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@(λ [c : has_mem.{u u} α (option.{u} α)] (a a_1 : α) (e_2 : @eq.{u+1} α a a_1)
                                    (a_2 a_3 : option.{u} α) (e_3 : @eq.{u+1} (option.{u} α) a_2 a_3),
                                      @congr.{u+1 1} (option.{u} α) Prop (@has_mem.mem.{u u} α (option.{u} α) c a)
                                        (@has_mem.mem.{u u} α (option.{u} α) c a_1)
                                        a_2
                                        a_3
                                        (@congr_arg.{u+1 (max (u+1) 1)} α (option.{u} α → Prop) a a_1
                                           (@has_mem.mem.{u u} α (option.{u} α) c)
                                           e_2)
                                        e_3)
                                     (@option.has_mem.{u} α)
                                     a
                                     a
                                     (@eq.refl.{u+1} α a)
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α))
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@if_pos.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        h
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@eq.refl.{1} Prop
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))))
                            (@dite.{0}
                               (@eq.{v+1} (option.{v} β)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (iff
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β))))
                               (λ
                                (h_1 :
                                  @eq.{v+1} (option.{v} β)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       f
                                       a)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       g
                                       a)),
                                  @eq.mpr.{0}
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@ite.{v+1}
                                             (@eq.{v+1} (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (option.{v} β)
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@option.none.{v} β))))
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                             (@pequiv.has_coe_to_fun.{u v} α β)
                                             f
                                             a)))
                                    (@id.{0}
                                       (@eq.{1} Prop
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@ite.{v+1}
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@option.none.{v} β))))
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a))))
                                       ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                         (e_2 : @eq.{1} Prop b b_1),
                                           @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                             (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                             e_2)
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@eq.refl.{1} Prop
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a))
                                          (@(λ [c : has_mem.{v v} β (option.{v} β)] (a a_1 : β)
                                            (e_2 : @eq.{v+1} β a a_1) (a_2 a_3 : option.{v} β)
                                            (e_3 : @eq.{v+1} (option.{v} β) a_2 a_3),
                                              @congr.{v+1 1} (option.{v} β) Prop
                                                (@has_mem.mem.{v v} β (option.{v} β) c a)
                                                (@has_mem.mem.{v v} β (option.{v} β) c a_1)
                                                a_2
                                                a_3
                                                (@congr_arg.{v+1 (max (v+1) 1)} β (option.{v} β → Prop) a a_1
                                                   (@has_mem.mem.{v v} β (option.{v} β) c)
                                                   e_2)
                                                e_3)
                                             (@option.has_mem.{v} β)
                                             b
                                             b
                                             (@eq.refl.{v+1} β b)
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β))
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@if_pos.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                h_1
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))))
                                    (@eq.mpr.{0}
                                       (iff
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)))
                                       true
                                       (@id.{0}
                                          (@eq.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             true)
                                          (@eq.trans.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             (iff
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b)))
                                             true
                                             ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                               (e_2 : @eq.{1} Prop b b_1),
                                                 @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                                   (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                                   e_2)
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.trans.{1} Prop
                                                   (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                         (pequiv.{v u} β α)
                                                         (@pequiv.has_coe_to_fun.{v u} β α)
                                                         (@pequiv.symm.{u v} α β f)
                                                         b))
                                                   (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a)
                                                      (@option.some.{v} β b))
                                                   (@eq.trans.{1} Prop
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β f)
                                                            b))
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β g)
                                                            b))
                                                      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                            (pequiv.{u v} α β)
                                                            (@pequiv.has_coe_to_fun.{u v} α β)
                                                            g
                                                            a))
                                                      (@(λ [c : has_mem.{u u} α (option.{u} α)] (a a_1 : α)
                                                        (e_2 : @eq.{u+1} α a a_1) (a_2 a_3 : option.{u} α)
                                                        (e_3 : @eq.{u+1} (option.{u} α) a_2 a_3), … e_3)
                                                         …
                                                         a
                                                         a
                                                         …
                                                         …
                                                         …
                                                         h)
                                                      …)
                                                   …)
                                                …
                                                …
                                                …)
                                             …))
                                       …))
                               …))
                       …)))
          _x
          _x)
       _x) →
  …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301    inf_le_right := λ _ _ _ _, by simp; split_ifs; cc,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1300, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Tries to prove the main goal using congruence closure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
_x _x : pequiv.{u v} α β,
_x : α,
_x : β
⊢ @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) _x
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@lattice.has_inf.inf.{(max u v)} (pequiv.{u v} α β)
          (@lattice.has_inf.mk.{(max u v)} (pequiv.{u v} α β)
             (λ (f g : pequiv.{u v} α β),
                @pequiv.mk.{u v} α β
                  (λ (a : α),
                     @ite.{v+1}
                       (@eq.{v+1} (option.{v} β)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (option.{v} β)
                       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                          (@pequiv.has_coe_to_fun.{u v} α β)
                          f
                          a)
                       (@option.none.{v} β))
                  (λ (b : β),
                     @ite.{u+1}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (option.{u} α)
                       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                          (@pequiv.has_coe_to_fun.{v u} β α)
                          (@pequiv.symm.{u v} α β f)
                          b)
                       (@option.none.{u} α))
                  (λ (a : α) (b : β),
                     @dite.{0}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (iff
                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                             (@ite.{u+1}
                                (@eq.{u+1} (option.{u} α)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (option.{u} α)
                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                   (@pequiv.symm.{u v} α β f)
                                   b)
                                (@option.none.{u} α)))
                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                             (@ite.{v+1}
                                (@eq.{v+1} (option.{v} β)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (option.{v} β)
                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                   f
                                   a)
                                (@option.none.{v} β))))
                       (λ
                        (h :
                          @eq.{u+1} (option.{u} α)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β f)
                               b)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β g)
                               b)),
                          @eq.mpr.{0}
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@ite.{u+1}
                                     (@eq.{u+1} (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (option.{u} α)
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@option.none.{u} α)))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                     (@pequiv.has_coe_to_fun.{v u} β α)
                                     (@pequiv.symm.{u v} α β f)
                                     b))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (@id.{0}
                               (@eq.{1} Prop
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@ite.{u+1}
                                           (@eq.{u+1} (option.{u} α)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@option.none.{u} α)))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β)))))
                               ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop) (e_2 : @eq.{1} Prop b b_1),
                                   @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                     (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                     e_2)
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@(λ [c : has_mem.{u u} α (option.{u} α)] (a a_1 : α) (e_2 : @eq.{u+1} α a a_1)
                                    (a_2 a_3 : option.{u} α) (e_3 : @eq.{u+1} (option.{u} α) a_2 a_3),
                                      @congr.{u+1 1} (option.{u} α) Prop (@has_mem.mem.{u u} α (option.{u} α) c a)
                                        (@has_mem.mem.{u u} α (option.{u} α) c a_1)
                                        a_2
                                        a_3
                                        (@congr_arg.{u+1 (max (u+1) 1)} α (option.{u} α → Prop) a a_1
                                           (@has_mem.mem.{u u} α (option.{u} α) c)
                                           e_2)
                                        e_3)
                                     (@option.has_mem.{u} α)
                                     a
                                     a
                                     (@eq.refl.{u+1} α a)
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α))
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@if_pos.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        h
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@eq.refl.{1} Prop
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))))
                            (@dite.{0}
                               (@eq.{v+1} (option.{v} β)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (iff
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β))))
                               (λ
                                (h_1 :
                                  @eq.{v+1} (option.{v} β)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       f
                                       a)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       g
                                       a)),
                                  @eq.mpr.{0}
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@ite.{v+1}
                                             (@eq.{v+1} (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (option.{v} β)
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@option.none.{v} β))))
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                             (@pequiv.has_coe_to_fun.{u v} α β)
                                             f
                                             a)))
                                    (@id.{0}
                                       (@eq.{1} Prop
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@ite.{v+1}
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@option.none.{v} β))))
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a))))
                                       ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                         (e_2 : @eq.{1} Prop b b_1),
                                           @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                             (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                             e_2)
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@eq.refl.{1} Prop
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a))
                                          (@(λ [c : has_mem.{v v} β (option.{v} β)] (a a_1 : β)
                                            (e_2 : @eq.{v+1} β a a_1) (a_2 a_3 : option.{v} β)
                                            (e_3 : @eq.{v+1} (option.{v} β) a_2 a_3),
                                              @congr.{v+1 1} (option.{v} β) Prop
                                                (@has_mem.mem.{v v} β (option.{v} β) c a)
                                                (@has_mem.mem.{v v} β (option.{v} β) c a_1)
                                                a_2
                                                a_3
                                                (@congr_arg.{v+1 (max (v+1) 1)} β (option.{v} β → Prop) a a_1
                                                   (@has_mem.mem.{v v} β (option.{v} β) c)
                                                   e_2)
                                                e_3)
                                             (@option.has_mem.{v} β)
                                             b
                                             b
                                             (@eq.refl.{v+1} β b)
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β))
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@if_pos.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                h_1
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))))
                                    (@eq.mpr.{0}
                                       (iff
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)))
                                       true
                                       (@id.{0}
                                          (@eq.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             true)
                                          (@eq.trans.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             (iff
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b)))
                                             true
                                             ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                               (e_2 : @eq.{1} Prop b b_1),
                                                 @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                                   (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                                   e_2)
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.trans.{1} Prop
                                                   (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                         (pequiv.{v u} β α)
                                                         (@pequiv.has_coe_to_fun.{v u} β α)
                                                         (@pequiv.symm.{u v} α β f)
                                                         b))
                                                   (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a)
                                                      (@option.some.{v} β b))
                                                   (@eq.trans.{1} Prop
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β f)
                                                            b))
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β g)
                                                            b))
                                                      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                            (pequiv.{u v} α β)
                                                            (@pequiv.has_coe_to_fun.{u v} α β)
                                                            g
                                                            a))
                                                      (@(λ [c : has_mem.{u u} α (option.{u} α)] (a a_1 : α)
                                                        (e_2 : @eq.{u+1} α a a_1) (a_2 a_3 : option.{u} α)
                                                        (e_3 : @eq.{u+1} (option.{u} α) a_2 a_3), … e_3)
                                                         …
                                                         a
                                                         a
                                                         …
                                                         …
                                                         …
                                                         h)
                                                      …)
                                                   …)
                                                …
                                                …
                                                …)
                                             …))
                                       …))
                               …))
                       …)))
          _x
          _x)
       _x) →
  …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302    le_inf := λ f g h fg gh a b, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='gh'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='pequiv.{u v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{(max u v)} (pequiv.{u v} α β) (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β) (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β) (@partial_order.mk.{(max u v)} (pequiv.{u v} α β) (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))))) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{(max u v)} (pequiv.{u v} α β) (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β) (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β) (@partial_order.mk.{(max u v)} (pequiv.{u v} α β) (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))))) f h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g h : pequiv.{u v} α β,
fg :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    g,
gh :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    h,
a : α,
b : β
⊢ @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@lattice.has_inf.inf.{(max u v)} (pequiv.{u v} α β)
          (@lattice.has_inf.mk.{(max u v)} (pequiv.{u v} α β)
             (λ (f g : pequiv.{u v} α β),
                @pequiv.mk.{u v} α β
                  (λ (a : α),
                     @ite.{v+1}
                       (@eq.{v+1} (option.{v} β)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (option.{v} β)
                       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                          (@pequiv.has_coe_to_fun.{u v} α β)
                          f
                          a)
                       (@option.none.{v} β))
                  (λ (b : β),
                     @ite.{u+1}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (option.{u} α)
                       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                          (@pequiv.has_coe_to_fun.{v u} β α)
                          (@pequiv.symm.{u v} α β f)
                          b)
                       (@option.none.{u} α))
                  (λ (a : α) (b : β),
                     @dite.{0}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (iff
                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                             (@ite.{u+1}
                                (@eq.{u+1} (option.{u} α)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (option.{u} α)
                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                   (@pequiv.symm.{u v} α β f)
                                   b)
                                (@option.none.{u} α)))
                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                             (@ite.{v+1}
                                (@eq.{v+1} (option.{v} β)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (option.{v} β)
                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                   f
                                   a)
                                (@option.none.{v} β))))
                       (λ
                        (h :
                          @eq.{u+1} (option.{u} α)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β f)
                               b)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β g)
                               b)),
                          @eq.mpr.{0}
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@ite.{u+1}
                                     (@eq.{u+1} (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (option.{u} α)
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@option.none.{u} α)))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                     (@pequiv.has_coe_to_fun.{v u} β α)
                                     (@pequiv.symm.{u v} α β f)
                                     b))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (@id.{0}
                               (@eq.{1} Prop
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@ite.{u+1}
                                           (@eq.{u+1} (option.{u} α)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@option.none.{u} α)))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β)))))
                               ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop) (e_2 : @eq.{1} Prop b b_1),
                                   @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                     (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                     e_2)
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@(λ [c : has_mem.{u u} α (option.{u} α)] (a a_1 : α) (e_2 : @eq.{u+1} α a a_1)
                                    (a_2 a_3 : option.{u} α) (e_3 : @eq.{u+1} (option.{u} α) a_2 a_3),
                                      @congr.{u+1 1} (option.{u} α) Prop (@has_mem.mem.{u u} α (option.{u} α) c a)
                                        (@has_mem.mem.{u u} α (option.{u} α) c a_1)
                                        a_2
                                        a_3
                                        (@congr_arg.{u+1 (max (u+1) 1)} α (option.{u} α → Prop) a a_1
                                           (@has_mem.mem.{u u} α (option.{u} α) c)
                                           e_2)
                                        e_3)
                                     (@option.has_mem.{u} α)
                                     a
                                     a
                                     (@eq.refl.{u+1} α a)
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α))
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@if_pos.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        h
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@eq.refl.{1} Prop
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))))
                            (@dite.{0}
                               (@eq.{v+1} (option.{v} β)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (iff
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β))))
                               (λ
                                (h_1 :
                                  @eq.{v+1} (option.{v} β)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       f
                                       a)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       g
                                       a)),
                                  @eq.mpr.{0}
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@ite.{v+1}
                                             (@eq.{v+1} (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (option.{v} β)
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@option.none.{v} β))))
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                             (@pequiv.has_coe_to_fun.{u v} α β)
                                             f
                                             a)))
                                    (@id.{0}
                                       (@eq.{1} Prop
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@ite.{v+1}
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@option.none.{v} β))))
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a))))
                                       ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                         (e_2 : @eq.{1} Prop b b_1),
                                           @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                             (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                             e_2)
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@eq.refl.{1} Prop
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a))
                                          (@(λ [c : has_mem.{v v} β (option.{v} β)] (a a_1 : β)
                                            (e_2 : @eq.{v+1} β a a_1) (a_2 a_3 : option.{v} β)
                                            (e_3 : @eq.{v+1} (option.{v} β) a_2 a_3),
                                              @congr.{v+1 1} (option.{v} β) Prop
                                                (@has_mem.mem.{v v} β (option.{v} β) c a)
                                                (@has_mem.mem.{v v} β (option.{v} β) c a_1)
                                                a_2
                                                a_3
                                                (@congr_arg.{v+1 (max (v+1) 1)} β (option.{v} β → Prop) a a_1
                                                   (@has_mem.mem.{v v} β (option.{v} β) c)
                                                   e_2)
                                                e_3)
                                             (@option.has_mem.{v} β)
                                             b
                                             b
                                             (@eq.refl.{v+1} β b)
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β))
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@if_pos.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                h_1
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))))
                                    (@eq.mpr.{0}
                                       (iff
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)))
                                       true
                                       (@id.{0}
                                          (@eq.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             true)
                                          (@eq.trans.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             (iff
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b)))
                                             true
                                             ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                               (e_2 : @eq.{1} Prop b b_1),
                                                 @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                                   (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                                   e_2)
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.trans.{1} Prop
                                                   (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                         (pequiv.{v u} β α)
                                                         (@pequiv.has_coe_to_fun.{v u} β α)
                                                         (@pequiv.symm.{u v} α β f)
                                                         b))
                                                   (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a)
                                                      (@option.some.{v} β b))
                                                   (@eq.trans.{1} Prop
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β f)
                                                            b))
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β g)
                                                            b))
                                                      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                            (pequiv.{u v} α β)
                                                            (@pequiv.has_coe_to_fun.{u v} α β)
                                                            g
                                                            a))
                                                      (… a … … … h)
                                                      …)
                                                   …)
                                                …
                                                …
                                                …)
                                             …))
                                       …))
                               …))
                       …)))
          g
          h)
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303      have := fg a b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='fg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{(max u v)} (pequiv.{u v} α β) (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β) (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β) (@partial_order.mk.{(max u v)} (pequiv.{u v} α β) (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))))) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g h : pequiv.{u v} α β,
fg :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    g,
gh :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    h,
a : α,
b : β
⊢ @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@lattice.has_inf.inf.{(max u v)} (pequiv.{u v} α β)
          (@lattice.has_inf.mk.{(max u v)} (pequiv.{u v} α β)
             (λ (f g : pequiv.{u v} α β),
                @pequiv.mk.{u v} α β
                  (λ (a : α),
                     @ite.{v+1}
                       (@eq.{v+1} (option.{v} β)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (option.{v} β)
                       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                          (@pequiv.has_coe_to_fun.{u v} α β)
                          f
                          a)
                       (@option.none.{v} β))
                  (λ (b : β),
                     @ite.{u+1}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (option.{u} α)
                       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                          (@pequiv.has_coe_to_fun.{v u} β α)
                          (@pequiv.symm.{u v} α β f)
                          b)
                       (@option.none.{u} α))
                  (λ (a : α) (b : β),
                     @dite.{0}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (iff
                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                             (@ite.{u+1}
                                (@eq.{u+1} (option.{u} α)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (option.{u} α)
                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                   (@pequiv.symm.{u v} α β f)
                                   b)
                                (@option.none.{u} α)))
                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                             (@ite.{v+1}
                                (@eq.{v+1} (option.{v} β)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (option.{v} β)
                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                   f
                                   a)
                                (@option.none.{v} β))))
                       (λ
                        (h :
                          @eq.{u+1} (option.{u} α)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β f)
                               b)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β g)
                               b)),
                          @eq.mpr.{0}
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@ite.{u+1}
                                     (@eq.{u+1} (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (option.{u} α)
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@option.none.{u} α)))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                     (@pequiv.has_coe_to_fun.{v u} β α)
                                     (@pequiv.symm.{u v} α β f)
                                     b))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (@id.{0}
                               (@eq.{1} Prop
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@ite.{u+1}
                                           (@eq.{u+1} (option.{u} α)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@option.none.{u} α)))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β)))))
                               ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop) (e_2 : @eq.{1} Prop b b_1),
                                   @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                     (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                     e_2)
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@(λ [c : has_mem.{u u} α (option.{u} α)] (a a_1 : α) (e_2 : @eq.{u+1} α a a_1)
                                    (a_2 a_3 : option.{u} α) (e_3 : @eq.{u+1} (option.{u} α) a_2 a_3),
                                      @congr.{u+1 1} (option.{u} α) Prop (@has_mem.mem.{u u} α (option.{u} α) c a)
                                        (@has_mem.mem.{u u} α (option.{u} α) c a_1)
                                        a_2
                                        a_3
                                        (@congr_arg.{u+1 (max (u+1) 1)} α (option.{u} α → Prop) a a_1
                                           (@has_mem.mem.{u u} α (option.{u} α) c)
                                           e_2)
                                        e_3)
                                     (@option.has_mem.{u} α)
                                     a
                                     a
                                     (@eq.refl.{u+1} α a)
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α))
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@if_pos.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        h
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@eq.refl.{1} Prop
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))))
                            (@dite.{0}
                               (@eq.{v+1} (option.{v} β)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (iff
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β))))
                               (λ
                                (h_1 :
                                  @eq.{v+1} (option.{v} β)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       f
                                       a)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       g
                                       a)),
                                  @eq.mpr.{0}
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@ite.{v+1}
                                             (@eq.{v+1} (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (option.{v} β)
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@option.none.{v} β))))
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                             (@pequiv.has_coe_to_fun.{u v} α β)
                                             f
                                             a)))
                                    (@id.{0}
                                       (@eq.{1} Prop
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@ite.{v+1}
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@option.none.{v} β))))
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a))))
                                       ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                         (e_2 : @eq.{1} Prop b b_1),
                                           @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                             (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                             e_2)
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@eq.refl.{1} Prop
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a))
                                          (@(λ [c : has_mem.{v v} β (option.{v} β)] (a a_1 : β)
                                            (e_2 : @eq.{v+1} β a a_1) (a_2 a_3 : option.{v} β)
                                            (e_3 : @eq.{v+1} (option.{v} β) a_2 a_3),
                                              @congr.{v+1 1} (option.{v} β) Prop
                                                (@has_mem.mem.{v v} β (option.{v} β) c a)
                                                (@has_mem.mem.{v v} β (option.{v} β) c a_1)
                                                a_2
                                                a_3
                                                (@congr_arg.{v+1 (max (v+1) 1)} β (option.{v} β → Prop) a a_1
                                                   (@has_mem.mem.{v v} β (option.{v} β) c)
                                                   e_2)
                                                e_3)
                                             (@option.has_mem.{v} β)
                                             b
                                             b
                                             (@eq.refl.{v+1} β b)
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β))
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@if_pos.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                h_1
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))))
                                    (@eq.mpr.{0}
                                       (iff
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)))
                                       true
                                       (@id.{0}
                                          (@eq.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             true)
                                          (@eq.trans.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             (iff
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b)))
                                             true
                                             ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                               (e_2 : @eq.{1} Prop b b_1),
                                                 @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                                   (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                                   e_2)
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.trans.{1} Prop
                                                   (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                         (pequiv.{v u} β α)
                                                         (@pequiv.has_coe_to_fun.{v u} β α)
                                                         (@pequiv.symm.{u v} α β f)
                                                         b))
                                                   (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a)
                                                      (@option.some.{v} β b))
                                                   (@eq.trans.{1} Prop
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β f)
                                                            b))
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β g)
                                                            b))
                                                      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                            (pequiv.{u v} α β)
                                                            (@pequiv.has_coe_to_fun.{u v} α β)
                                                            g
                                                            a))
                                                      (… a … … … h)
                                                      …)
                                                   …)
                                                …
                                                …
                                                …)
                                             …))
                                       …))
                               …))
                       …)))
          g
          h)
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g h : pequiv.{u v} α β,
fg :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    g,
gh :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    h,
a : α,
b : β,
this :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
⊢ @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@lattice.has_inf.inf.{(max u v)} (pequiv.{u v} α β)
          (@lattice.has_inf.mk.{(max u v)} (pequiv.{u v} α β)
             (λ (f g : pequiv.{u v} α β),
                @pequiv.mk.{u v} α β
                  (λ (a : α),
                     @ite.{v+1}
                       (@eq.{v+1} (option.{v} β)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (option.{v} β)
                       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                          (@pequiv.has_coe_to_fun.{u v} α β)
                          f
                          a)
                       (@option.none.{v} β))
                  (λ (b : β),
                     @ite.{u+1}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (option.{u} α)
                       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                          (@pequiv.has_coe_to_fun.{v u} β α)
                          (@pequiv.symm.{u v} α β f)
                          b)
                       (@option.none.{u} α))
                  (λ (a : α) (b : β),
                     @dite.{0}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (iff
                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                             (@ite.{u+1}
                                (@eq.{u+1} (option.{u} α)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (option.{u} α)
                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                   (@pequiv.symm.{u v} α β f)
                                   b)
                                (@option.none.{u} α)))
                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                             (@ite.{v+1}
                                (@eq.{v+1} (option.{v} β)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (option.{v} β)
                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                   f
                                   a)
                                (@option.none.{v} β))))
                       (λ
                        (h :
                          @eq.{u+1} (option.{u} α)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β f)
                               b)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β g)
                               b)),
                          @eq.mpr.{0}
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@ite.{u+1}
                                     (@eq.{u+1} (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (option.{u} α)
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@option.none.{u} α)))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                     (@pequiv.has_coe_to_fun.{v u} β α)
                                     (@pequiv.symm.{u v} α β f)
                                     b))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (@id.{0}
                               (@eq.{1} Prop
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@ite.{u+1}
                                           (@eq.{u+1} (option.{u} α)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@option.none.{u} α)))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β)))))
                               ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop) (e_2 : @eq.{1} Prop b b_1),
                                   @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                     (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                     e_2)
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@(λ [c : has_mem.{u u} α (option.{u} α)] (a a_1 : α) (e_2 : @eq.{u+1} α a a_1)
                                    (a_2 a_3 : option.{u} α) (e_3 : @eq.{u+1} (option.{u} α) a_2 a_3),
                                      @congr.{u+1 1} (option.{u} α) Prop (@has_mem.mem.{u u} α (option.{u} α) c a)
                                        (@has_mem.mem.{u u} α (option.{u} α) c a_1)
                                        a_2
                                        a_3
                                        (@congr_arg.{u+1 (max (u+1) 1)} α (option.{u} α → Prop) a a_1
                                           (@has_mem.mem.{u u} α (option.{u} α) c)
                                           e_2)
                                        e_3)
                                     (@option.has_mem.{u} α)
                                     a
                                     a
                                     (@eq.refl.{u+1} α a)
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α))
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@if_pos.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        h
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@eq.refl.{1} Prop
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))))
                            (@dite.{0}
                               (@eq.{v+1} (option.{v} β)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (iff
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β))))
                               (λ
                                (h_1 :
                                  @eq.{v+1} (option.{v} β)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       f
                                       a)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       g
                                       a)),
                                  @eq.mpr.{0}
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@ite.{v+1}
                                             (@eq.{v+1} (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (option.{v} β)
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@option.none.{v} β))))
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                             (@pequiv.has_coe_to_fun.{u v} α β)
                                             f
                                             a)))
                                    (@id.{0}
                                       (@eq.{1} Prop
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@ite.{v+1}
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@option.none.{v} β))))
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a))))
                                       ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                         (e_2 : @eq.{1} Prop b b_1),
                                           @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                             (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                             e_2)
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@eq.refl.{1} Prop
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a))
                                          (@(λ [c : has_mem.{v v} β (option.{v} β)] (a a_1 : β)
                                            (e_2 : @eq.{v+1} β a a_1) (a_2 a_3 : option.{v} β)
                                            (e_3 : @eq.{v+1} (option.{v} β) a_2 a_3),
                                              @congr.{v+1 1} (option.{v} β) Prop
                                                (@has_mem.mem.{v v} β (option.{v} β) c a)
                                                (@has_mem.mem.{v v} β (option.{v} β) c a_1)
                                                a_2
                                                a_3
                                                (@congr_arg.{v+1 (max (v+1) 1)} β (option.{v} β → Prop) a a_1
                                                   (@has_mem.mem.{v v} β (option.{v} β) c)
                                                   e_2)
                                                e_3)
                                             (@option.has_mem.{v} β)
                                             b
                                             b
                                             (@eq.refl.{v+1} β b)
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β))
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@if_pos.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                h_1
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))))
                                    (@eq.mpr.{0}
                                       (iff
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)))
                                       true
                                       (@id.{0}
                                          (@eq.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             true)
                                          (@eq.trans.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             (iff
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b)))
                                             true
                                             ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                               (e_2 : @eq.{1} Prop b b_1),
                                                 @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                                   (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                                   e_2)
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.trans.{1} Prop
                                                   (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                         (pequiv.{v u} β α)
                                                         (@pequiv.has_coe_to_fun.{v u} β α)
                                                         (@pequiv.symm.{u v} α β f)
                                                         b))
                                                   (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a)
                                                      (@option.some.{v} β b))
                                                   (@eq.trans.{1} Prop
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β f)
                                                            b))
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β g)
                                                            b))
                                                      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                            (pequiv.{u v} α β)
                                                            (@pequiv.has_coe_to_fun.{u v} α β)
                                                            g
                                                            a))
                                                      (… a … … … h)
                                                      …)
                                                   …)
                                                …
                                                …
                                                …)
                                             …))
                                       …))
                               …))
                       …)))
          g
          h)
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304      have := gh a b,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='gh'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{(max u v)} (pequiv.{u v} α β) (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β) (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β) (@partial_order.mk.{(max u v)} (pequiv.{u v} α β) (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β)) (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))))) f h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g h : pequiv.{u v} α β,
fg :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    g,
gh :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    h,
a : α,
b : β,
this :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
⊢ @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@lattice.has_inf.inf.{(max u v)} (pequiv.{u v} α β)
          (@lattice.has_inf.mk.{(max u v)} (pequiv.{u v} α β)
             (λ (f g : pequiv.{u v} α β),
                @pequiv.mk.{u v} α β
                  (λ (a : α),
                     @ite.{v+1}
                       (@eq.{v+1} (option.{v} β)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (option.{v} β)
                       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                          (@pequiv.has_coe_to_fun.{u v} α β)
                          f
                          a)
                       (@option.none.{v} β))
                  (λ (b : β),
                     @ite.{u+1}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (option.{u} α)
                       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                          (@pequiv.has_coe_to_fun.{v u} β α)
                          (@pequiv.symm.{u v} α β f)
                          b)
                       (@option.none.{u} α))
                  (λ (a : α) (b : β),
                     @dite.{0}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (iff
                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                             (@ite.{u+1}
                                (@eq.{u+1} (option.{u} α)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (option.{u} α)
                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                   (@pequiv.symm.{u v} α β f)
                                   b)
                                (@option.none.{u} α)))
                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                             (@ite.{v+1}
                                (@eq.{v+1} (option.{v} β)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (option.{v} β)
                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                   f
                                   a)
                                (@option.none.{v} β))))
                       (λ
                        (h :
                          @eq.{u+1} (option.{u} α)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β f)
                               b)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β g)
                               b)),
                          @eq.mpr.{0}
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@ite.{u+1}
                                     (@eq.{u+1} (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (option.{u} α)
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@option.none.{u} α)))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                     (@pequiv.has_coe_to_fun.{v u} β α)
                                     (@pequiv.symm.{u v} α β f)
                                     b))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (@id.{0}
                               (@eq.{1} Prop
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@ite.{u+1}
                                           (@eq.{u+1} (option.{u} α)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@option.none.{u} α)))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β)))))
                               ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop) (e_2 : @eq.{1} Prop b b_1),
                                   @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                     (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                     e_2)
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@(λ [c : has_mem.{u u} α (option.{u} α)] (a a_1 : α) (e_2 : @eq.{u+1} α a a_1)
                                    (a_2 a_3 : option.{u} α) (e_3 : @eq.{u+1} (option.{u} α) a_2 a_3),
                                      @congr.{u+1 1} (option.{u} α) Prop (@has_mem.mem.{u u} α (option.{u} α) c a)
                                        (@has_mem.mem.{u u} α (option.{u} α) c a_1)
                                        a_2
                                        a_3
                                        (@congr_arg.{u+1 (max (u+1) 1)} α (option.{u} α → Prop) a a_1
                                           (@has_mem.mem.{u u} α (option.{u} α) c)
                                           e_2)
                                        e_3)
                                     (@option.has_mem.{u} α)
                                     a
                                     a
                                     (@eq.refl.{u+1} α a)
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α))
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@if_pos.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        h
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@eq.refl.{1} Prop
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))))
                            (@dite.{0}
                               (@eq.{v+1} (option.{v} β)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (iff
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β))))
                               (λ
                                (h_1 :
                                  @eq.{v+1} (option.{v} β)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       f
                                       a)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       g
                                       a)),
                                  @eq.mpr.{0}
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@ite.{v+1}
                                             (@eq.{v+1} (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (option.{v} β)
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@option.none.{v} β))))
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                             (@pequiv.has_coe_to_fun.{u v} α β)
                                             f
                                             a)))
                                    (@id.{0}
                                       (@eq.{1} Prop
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@ite.{v+1}
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@option.none.{v} β))))
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a))))
                                       ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                         (e_2 : @eq.{1} Prop b b_1),
                                           @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                             (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                             e_2)
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@eq.refl.{1} Prop
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a))
                                          (@(λ [c : has_mem.{v v} β (option.{v} β)] (a a_1 : β)
                                            (e_2 : @eq.{v+1} β a a_1) (a_2 a_3 : option.{v} β)
                                            (e_3 : @eq.{v+1} (option.{v} β) a_2 a_3),
                                              @congr.{v+1 1} (option.{v} β) Prop
                                                (@has_mem.mem.{v v} β (option.{v} β) c a)
                                                (@has_mem.mem.{v v} β (option.{v} β) c a_1)
                                                a_2
                                                a_3
                                                (@congr_arg.{v+1 (max (v+1) 1)} β (option.{v} β → Prop) a a_1
                                                   (@has_mem.mem.{v v} β (option.{v} β) c)
                                                   e_2)
                                                e_3)
                                             (@option.has_mem.{v} β)
                                             b
                                             b
                                             (@eq.refl.{v+1} β b)
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β))
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@if_pos.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                h_1
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))))
                                    (@eq.mpr.{0}
                                       (iff
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)))
                                       true
                                       (@id.{0}
                                          (@eq.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             true)
                                          (@eq.trans.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             (iff
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b)))
                                             true
                                             ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                               (e_2 : @eq.{1} Prop b b_1),
                                                 @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                                   (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                                   e_2)
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.trans.{1} Prop
                                                   (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                         (pequiv.{v u} β α)
                                                         (@pequiv.has_coe_to_fun.{v u} β α)
                                                         (@pequiv.symm.{u v} α β f)
                                                         b))
                                                   (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a)
                                                      (@option.some.{v} β b))
                                                   (@eq.trans.{1} Prop
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β f)
                                                            b))
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β g)
                                                            b))
                                                      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                            (pequiv.{u v} α β)
                                                            (@pequiv.has_coe_to_fun.{u v} α β)
                                                            g
                                                            a))
                                                      (… a … … … h)
                                                      …)
                                                   …)
                                                …
                                                …
                                                …)
                                             …))
                                       …))
                               …))
                       …)))
          g
          h)
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g h : pequiv.{u v} α β,
fg :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    g,
gh :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    h,
a : α,
b : β,
this :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a),
this :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) h a)
⊢ @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@lattice.has_inf.inf.{(max u v)} (pequiv.{u v} α β)
          (@lattice.has_inf.mk.{(max u v)} (pequiv.{u v} α β)
             (λ (f g : pequiv.{u v} α β),
                @pequiv.mk.{u v} α β
                  (λ (a : α),
                     @ite.{v+1}
                       (@eq.{v+1} (option.{v} β)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (option.{v} β)
                       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                          (@pequiv.has_coe_to_fun.{u v} α β)
                          f
                          a)
                       (@option.none.{v} β))
                  (λ (b : β),
                     @ite.{u+1}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (option.{u} α)
                       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                          (@pequiv.has_coe_to_fun.{v u} β α)
                          (@pequiv.symm.{u v} α β f)
                          b)
                       (@option.none.{u} α))
                  (λ (a : α) (b : β),
                     @dite.{0}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (iff
                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                             (@ite.{u+1}
                                (@eq.{u+1} (option.{u} α)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (option.{u} α)
                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                   (@pequiv.symm.{u v} α β f)
                                   b)
                                (@option.none.{u} α)))
                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                             (@ite.{v+1}
                                (@eq.{v+1} (option.{v} β)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (option.{v} β)
                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                   f
                                   a)
                                (@option.none.{v} β))))
                       (λ
                        (h :
                          @eq.{u+1} (option.{u} α)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β f)
                               b)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β g)
                               b)),
                          @eq.mpr.{0}
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@ite.{u+1}
                                     (@eq.{u+1} (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (option.{u} α)
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@option.none.{u} α)))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                     (@pequiv.has_coe_to_fun.{v u} β α)
                                     (@pequiv.symm.{u v} α β f)
                                     b))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (@id.{0}
                               (@eq.{1} Prop
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@ite.{u+1}
                                           (@eq.{u+1} (option.{u} α)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@option.none.{u} α)))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β)))))
                               ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop) (e_2 : @eq.{1} Prop b b_1),
                                   @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                     (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                     e_2)
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@(λ [c : has_mem.{u u} α (option.{u} α)] (a a_1 : α) (e_2 : @eq.{u+1} α a a_1)
                                    (a_2 a_3 : option.{u} α) (e_3 : @eq.{u+1} (option.{u} α) a_2 a_3),
                                      @congr.{u+1 1} (option.{u} α) Prop (@has_mem.mem.{u u} α (option.{u} α) c a)
                                        (@has_mem.mem.{u u} α (option.{u} α) c a_1)
                                        a_2
                                        a_3
                                        (@congr_arg.{u+1 (max (u+1) 1)} α (option.{u} α → Prop) a a_1
                                           (@has_mem.mem.{u u} α (option.{u} α) c)
                                           e_2)
                                        e_3)
                                     (@option.has_mem.{u} α)
                                     a
                                     a
                                     (@eq.refl.{u+1} α a)
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α))
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@if_pos.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        h
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@eq.refl.{1} Prop
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))))
                            (@dite.{0}
                               (@eq.{v+1} (option.{v} β)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (iff
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β))))
                               (λ
                                (h_1 :
                                  @eq.{v+1} (option.{v} β)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       f
                                       a)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       g
                                       a)),
                                  @eq.mpr.{0}
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@ite.{v+1}
                                             (@eq.{v+1} (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (option.{v} β)
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@option.none.{v} β))))
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                             (@pequiv.has_coe_to_fun.{u v} α β)
                                             f
                                             a)))
                                    (@id.{0}
                                       (@eq.{1} Prop
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@ite.{v+1}
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@option.none.{v} β))))
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a))))
                                       ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                         (e_2 : @eq.{1} Prop b b_1),
                                           @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                             (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                             e_2)
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@eq.refl.{1} Prop
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a))
                                          (@(λ [c : has_mem.{v v} β (option.{v} β)] (a a_1 : β)
                                            (e_2 : @eq.{v+1} β a a_1) (a_2 a_3 : option.{v} β)
                                            (e_3 : @eq.{v+1} (option.{v} β) a_2 a_3),
                                              @congr.{v+1 1} (option.{v} β) Prop
                                                (@has_mem.mem.{v v} β (option.{v} β) c a)
                                                (@has_mem.mem.{v v} β (option.{v} β) c a_1)
                                                a_2
                                                a_3
                                                (@congr_arg.{v+1 (max (v+1) 1)} β (option.{v} β → Prop) a a_1
                                                   (@has_mem.mem.{v v} β (option.{v} β) c)
                                                   e_2)
                                                e_3)
                                             (@option.has_mem.{v} β)
                                             b
                                             b
                                             (@eq.refl.{v+1} β b)
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β))
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@if_pos.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                h_1
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))))
                                    (@eq.mpr.{0}
                                       (iff
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)))
                                       true
                                       (@id.{0}
                                          (@eq.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             true)
                                          (@eq.trans.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             (iff
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b)))
                                             true
                                             ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                               (e_2 : @eq.{1} Prop b b_1),
                                                 @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                                   (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                                   e_2)
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.trans.{1} Prop
                                                   (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                         (pequiv.{v u} β α)
                                                         (@pequiv.has_coe_to_fun.{v u} β α)
                                                         (@pequiv.symm.{u v} α β f)
                                                         b))
                                                   (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a)
                                                      (@option.some.{v} β b))
                                                   (@eq.trans.{1} Prop
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β f)
                                                            b))
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β g)
                                                            b))
                                                      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                            (pequiv.{u v} α β)
                                                            (@pequiv.has_coe_to_fun.{u v} α β)
                                                            g
                                                            a))
                                                      (… a … … … h)
                                                      …)
                                                   …)
                                                …
                                                …
                                                …)
                                             …))
                                       …))
                               …))
                       …)))
          g
          h)
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305      simp [le_def],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='pequiv.le_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {f g : pequiv.{?l_1 ?l_2} α β}, iff (@has_le.le.{(max ?l_1 ?l_2)} (pequiv.{?l_1 ?l_2} α β) (@preorder.to_has_le.{(max ?l_1 ?l_2)} (pequiv.{?l_1 ?l_2} α β) (@partial_order.to_preorder.{(max ?l_1 ?l_2)} (pequiv.{?l_1 ?l_2} α β) (@pequiv.partial_order.{?l_1 ?l_2} α β))) f g) (∀ (a : α) (b : β), @has_mem.mem.{?l_2 ?l_2} β (option.{?l_2} β) (@option.has_mem.{?l_2} β) b (@coe_fn.{(max (?l_1+1) (?l_2+1)) (max (?l_1+1) (?l_2+1))} (pequiv.{?l_1 ?l_2} α β) (@pequiv.has_coe_to_fun.{?l_1 ?l_2} α β) f a) → @has_mem.mem.{?l_2 ?l_2} β (option.{?l_2} β) (@option.has_mem.{?l_2} β) b (@coe_fn.{(max (?l_1+1) (?l_2+1)) (max (?l_1+1) (?l_2+1))} (pequiv.{?l_1 ?l_2} α β) (@pequiv.has_coe_to_fun.{?l_1 ?l_2} α β) g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g h : pequiv.{u v} α β,
fg :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    g,
gh :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    h,
a : α,
b : β,
this :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a),
this :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) h a)
⊢ @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β)
       (@lattice.has_inf.inf.{(max u v)} (pequiv.{u v} α β)
          (@lattice.has_inf.mk.{(max u v)} (pequiv.{u v} α β)
             (λ (f g : pequiv.{u v} α β),
                @pequiv.mk.{u v} α β
                  (λ (a : α),
                     @ite.{v+1}
                       (@eq.{v+1} (option.{v} β)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             f
                             a)
                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                             (@pequiv.has_coe_to_fun.{u v} α β)
                             g
                             a))
                       (option.{v} β)
                       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                          (@pequiv.has_coe_to_fun.{u v} α β)
                          f
                          a)
                       (@option.none.{v} β))
                  (λ (b : β),
                     @ite.{u+1}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (option.{u} α)
                       (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                          (@pequiv.has_coe_to_fun.{v u} β α)
                          (@pequiv.symm.{u v} α β f)
                          b)
                       (@option.none.{u} α))
                  (λ (a : α) (b : β),
                     @dite.{0}
                       (@eq.{u+1} (option.{u} α)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β f)
                             b)
                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                             (@pequiv.has_coe_to_fun.{v u} β α)
                             (@pequiv.symm.{u v} α β g)
                             b))
                       (iff
                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                             (@ite.{u+1}
                                (@eq.{u+1} (option.{u} α)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β f)
                                      b)
                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                      (@pequiv.symm.{u v} α β g)
                                      b))
                                (option.{u} α)
                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                   (@pequiv.symm.{u v} α β f)
                                   b)
                                (@option.none.{u} α)))
                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                             (@ite.{v+1}
                                (@eq.{v+1} (option.{v} β)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      f
                                      a)
                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                      g
                                      a))
                                (option.{v} β)
                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                   f
                                   a)
                                (@option.none.{v} β))))
                       (λ
                        (h :
                          @eq.{u+1} (option.{u} α)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β f)
                               b)
                            (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                               (@pequiv.has_coe_to_fun.{v u} β α)
                               (@pequiv.symm.{u v} α β g)
                               b)),
                          @eq.mpr.{0}
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@ite.{u+1}
                                     (@eq.{u+1} (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β g)
                                           b))
                                     (option.{u} α)
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@option.none.{u} α)))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (iff
                               (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                  (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                     (@pequiv.has_coe_to_fun.{v u} β α)
                                     (@pequiv.symm.{u v} α β f)
                                     b))
                               (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                  (@ite.{v+1}
                                     (@eq.{v+1} (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           g
                                           a))
                                     (option.{v} β)
                                     (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                        (@pequiv.has_coe_to_fun.{u v} α β)
                                        f
                                        a)
                                     (@option.none.{v} β))))
                            (@id.{0}
                               (@eq.{1} Prop
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@ite.{u+1}
                                           (@eq.{u+1} (option.{u} α)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β f)
                                                 b)
                                              (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                 (@pequiv.has_coe_to_fun.{v u} β α)
                                                 (@pequiv.symm.{u v} α β g)
                                                 b))
                                           (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@option.none.{u} α)))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))
                                  (iff
                                     (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b))
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β)))))
                               ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop) (e_2 : @eq.{1} Prop b b_1),
                                   @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                     (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                     e_2)
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@(λ [c : has_mem.{u u} α (option.{u} α)] (a a_1 : α) (e_2 : @eq.{u+1} α a a_1)
                                    (a_2 a_3 : option.{u} α) (e_3 : @eq.{u+1} (option.{u} α) a_2 a_3),
                                      @congr.{u+1 1} (option.{u} α) Prop (@has_mem.mem.{u u} α (option.{u} α) c a)
                                        (@has_mem.mem.{u u} α (option.{u} α) c a_1)
                                        a_2
                                        a_3
                                        (@congr_arg.{u+1 (max (u+1) 1)} α (option.{u} α → Prop) a a_1
                                           (@has_mem.mem.{u u} α (option.{u} α) c)
                                           e_2)
                                        e_3)
                                     (@option.has_mem.{u} α)
                                     a
                                     a
                                     (@eq.refl.{u+1} α a)
                                     (@ite.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α))
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b)
                                     (@if_pos.{u+1}
                                        (@eq.{u+1} (option.{u} α)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        (@option.decidable_eq.{u} α (λ (a b : α), _inst_1 a b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β f)
                                              b)
                                           (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                              (@pequiv.has_coe_to_fun.{v u} β α)
                                              (@pequiv.symm.{u v} α β g)
                                              b))
                                        h
                                        (option.{u} α)
                                        (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                           (@pequiv.has_coe_to_fun.{v u} β α)
                                           (@pequiv.symm.{u v} α β f)
                                           b)
                                        (@option.none.{u} α)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β)))
                                  (@eq.refl.{1} Prop
                                     (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                        (@ite.{v+1}
                                           (@eq.{v+1} (option.{v} β)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 f
                                                 a)
                                              (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                 (@pequiv.has_coe_to_fun.{u v} α β)
                                                 g
                                                 a))
                                           (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@option.none.{v} β))))))
                            (@dite.{0}
                               (@eq.{v+1} (option.{v} β)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     f
                                     a)
                                  (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                     (@pequiv.has_coe_to_fun.{u v} α β)
                                     g
                                     a))
                               (iff
                                  (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                     (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                        (@pequiv.has_coe_to_fun.{v u} β α)
                                        (@pequiv.symm.{u v} α β f)
                                        b))
                                  (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                     (@ite.{v+1}
                                        (@eq.{v+1} (option.{v} β)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              f
                                              a)
                                           (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                              (@pequiv.has_coe_to_fun.{u v} α β)
                                              g
                                              a))
                                        (option.{v} β)
                                        (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                           (@pequiv.has_coe_to_fun.{u v} α β)
                                           f
                                           a)
                                        (@option.none.{v} β))))
                               (λ
                                (h_1 :
                                  @eq.{v+1} (option.{v} β)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       f
                                       a)
                                    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                       (@pequiv.has_coe_to_fun.{u v} α β)
                                       g
                                       a)),
                                  @eq.mpr.{0}
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@ite.{v+1}
                                             (@eq.{v+1} (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   g
                                                   a))
                                             (option.{v} β)
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@option.none.{v} β))))
                                    (iff
                                       (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                          (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                             (@pequiv.has_coe_to_fun.{v u} β α)
                                             (@pequiv.symm.{u v} α β f)
                                             b))
                                       (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                             (@pequiv.has_coe_to_fun.{u v} α β)
                                             f
                                             a)))
                                    (@id.{0}
                                       (@eq.{1} Prop
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@ite.{v+1}
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         f
                                                         a)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@option.none.{v} β))))
                                          (iff
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b))
                                             (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a))))
                                       ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                         (e_2 : @eq.{1} Prop b b_1),
                                           @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                             (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                             e_2)
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@eq.refl.{1} Prop
                                             (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                   (@pequiv.has_coe_to_fun.{v u} β α)
                                                   (@pequiv.symm.{u v} α β f)
                                                   b)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a))
                                          (@(λ [c : has_mem.{v v} β (option.{v} β)] (a a_1 : β)
                                            (e_2 : @eq.{v+1} β a a_1) (a_2 a_3 : option.{v} β)
                                            (e_3 : @eq.{v+1} (option.{v} β) a_2 a_3),
                                              @congr.{v+1 1} (option.{v} β) Prop
                                                (@has_mem.mem.{v v} β (option.{v} β) c a)
                                                (@has_mem.mem.{v v} β (option.{v} β) c a_1)
                                                a_2
                                                a_3
                                                (@congr_arg.{v+1 (max (v+1) 1)} β (option.{v} β → Prop) a a_1
                                                   (@has_mem.mem.{v v} β (option.{v} β) c)
                                                   e_2)
                                                e_3)
                                             (@option.has_mem.{v} β)
                                             b
                                             b
                                             (@eq.refl.{v+1} β b)
                                             (@ite.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β))
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)
                                             (@if_pos.{v+1}
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a))
                                                h_1
                                                (option.{v} β)
                                                (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                   (@pequiv.has_coe_to_fun.{u v} α β)
                                                   f
                                                   a)
                                                (@option.none.{v} β)))))
                                    (@eq.mpr.{0}
                                       (iff
                                          (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                             (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                (@pequiv.has_coe_to_fun.{v u} β α)
                                                (@pequiv.symm.{u v} α β f)
                                                b))
                                          (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                             (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                (@pequiv.has_coe_to_fun.{u v} α β)
                                                f
                                                a)))
                                       true
                                       (@id.{0}
                                          (@eq.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             true)
                                          (@eq.trans.{1} Prop
                                             (iff
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      f
                                                      a)))
                                             (iff
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b)))
                                             true
                                             ((λ (a a_1 : Prop) (e_1 : @eq.{1} Prop a a_1) (b b_1 : Prop)
                                               (e_2 : @eq.{1} Prop b b_1),
                                                 @congr.{1 1} Prop Prop (iff a) (iff a_1) b b_1
                                                   (@congr_arg.{1 1} Prop (Prop → Prop) a a_1 iff e_1)
                                                   e_2)
                                                (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                   (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))} (pequiv.{v u} β α)
                                                      (@pequiv.has_coe_to_fun.{v u} β α)
                                                      (@pequiv.symm.{u v} α β f)
                                                      b))
                                                (@eq.{v+1} (option.{v} β)
                                                   (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β)
                                                      (@pequiv.has_coe_to_fun.{u v} α β)
                                                      g
                                                      a)
                                                   (@option.some.{v} β b))
                                                (@eq.trans.{1} Prop
                                                   (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                      (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                         (pequiv.{v u} β α)
                                                         (@pequiv.has_coe_to_fun.{v u} β α)
                                                         (@pequiv.symm.{u v} α β f)
                                                         b))
                                                   (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a))
                                                   (@eq.{v+1} (option.{v} β)
                                                      (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                         (pequiv.{u v} α β)
                                                         (@pequiv.has_coe_to_fun.{u v} α β)
                                                         g
                                                         a)
                                                      (@option.some.{v} β b))
                                                   (@eq.trans.{1} Prop
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β f)
                                                            b))
                                                      (@has_mem.mem.{u u} α (option.{u} α) (@option.has_mem.{u} α) a
                                                         (@coe_fn.{(max (v+1) (u+1)) (max (v+1) (u+1))}
                                                            (pequiv.{v u} β α)
                                                            (@pequiv.has_coe_to_fun.{v u} β α)
                                                            (@pequiv.symm.{u v} α β g)
                                                            b))
                                                      (@has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
                                                         (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))}
                                                            (pequiv.{u v} α β)
                                                            (@pequiv.has_coe_to_fun.{u v} α β)
                                                            g
                                                            a))
                                                      (… a … … … h)
                                                      …)
                                                   …)
                                                …
                                                …
                                                …)
                                             …))
                                       …))
                               …))
                       …)))
          g
          h)
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g h : pequiv.{u v} α β,
fg :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    g,
gh :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    h,
a : α,
b : β,
this :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a),
this :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) h a)
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.some.{v} β b) →
  @eq.{v+1} (option.{v} β)
    (@ite.{v+1}
       (@eq.{v+1} (option.{v} β)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) h a))
       (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) h a))
       (option.{v} β)
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
       (@option.none.{v} β))
    (@option.some.{v} β b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306      split_ifs; finish</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g h : pequiv.{u v} α β,
fg :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    g,
gh :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    h,
a : α,
b : β,
this :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a),
this :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) h a)
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.some.{v} β b) →
  @eq.{v+1} (option.{v} β)
    (@ite.{v+1}
       (@eq.{v+1} (option.{v} β)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) h a))
       (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) h a))
       (option.{v} β)
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
       (@option.none.{v} β))
    (@option.some.{v} β b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307    end,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : decidable_eq.{u+1} α,
_inst_2 : decidable_eq.{v+1} β,
f g h : pequiv.{u v} α β,
fg :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    g,
gh :
  @has_le.le.{(max u v)} (pequiv.{u v} α β)
    (@preorder.to_has_le.{(max u v)} (pequiv.{u v} α β)
       (@partial_order.to_preorder.{(max u v)} (pequiv.{u v} α β)
          (@partial_order.mk.{(max u v)} (pequiv.{u v} α β)
             (@lattice.order_bot.le.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_refl.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_trans.{(max u v)} (pequiv.{u v} α β) (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.lt_iff_le_not_le.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β))
             (@lattice.order_bot.le_antisymm.{(max u v)} (pequiv.{u v} α β)
                (@pequiv.lattice.order_bot.{u v} α β)))))
    f
    h,
a : α,
b : β,
this :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a),
this :
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a) →
  @has_mem.mem.{v v} β (option.{v} β) (@option.has_mem.{v} β) b
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) h a)
⊢ @eq.{v+1} (option.{v} β)
    (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) f a)
    (@option.some.{v} β b) →
  @eq.{v+1} (option.{v} β)
    (@ite.{v+1}
       (@eq.{v+1} (option.{v} β)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) h a))
       (@option.decidable_eq.{v} β (λ (a b : β), _inst_2 a b)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
          (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) h a))
       (option.{v} β)
       (@coe_fn.{(max (u+1) (v+1)) (max (u+1) (v+1))} (pequiv.{u v} α β) (@pequiv.has_coe_to_fun.{u v} α β) g a)
       (@option.none.{v} β))
    (@option.some.{v} β b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308    ..pequiv.lattice.order_bot }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='pequiv.lattice.order_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 286, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v}, lattice.order_bot.{(max u v)} (pequiv.{u v} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310  end order</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312  end pequiv</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314  namespace equiv</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315  variables {α : Type*} {β : Type*} {γ : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317  def to_pequiv (f : α ≃ β) : α ≃. β :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 13, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2 → Type (max (max u_1 u_2) u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2 → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A `pequiv` is a partial equivalence, a representation of a bijection between a subset
 of `α` and a subset of `β`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318  { to_fun := some ∘ f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β φ : Type u_2}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.{u_1+1 u_2+1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319    inv_fun := some ∘ f.symm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β φ : Type u_1}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.{u_1+1 u_2+1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, equiv.{u_1+1 u_2+1} α β → equiv.{u_2+1 u_1+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320    inv := by simp [equiv.eq_symm_apply, eq_comm] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='equiv.eq_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {β : Sort ?l_2} (e : equiv.{?l_1 ?l_2} α β) {x : β} {y : α}, iff (@eq.{?l_1} α y (@coe_fn.{(max 1 (imax ?l_2 ?l_1) (imax ?l_1 ?l_2)) (imax ?l_2 ?l_1)} (equiv.{?l_2 ?l_1} β α) (@equiv.has_coe_to_fun.{?l_2 ?l_1} β α) (@equiv.symm.{?l_1 ?l_2} α β e) x)) (@eq.{?l_2} β (@coe_fn.{(max 1 (imax ?l_1 ?l_2) (imax ?l_2 ?l_1)) (imax ?l_1 ?l_2)} (equiv.{?l_1 ?l_2} α β) (@equiv.has_coe_to_fun.{?l_1 ?l_2} α β) e y) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {a b : α}, iff (@eq.{?l_1} α a b) (@eq.{?l_1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
f : equiv.{u_1+1 u_2+1} α β
⊢ ∀ (a : α) (b : β),
    iff
      (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a
         (@function.comp.{u_2+1 u_1+1 u_1+1} β α (option.{u_1} α) (@option.some.{u_1} α)
            (@coe_fn.{(max 1 (max (u_2+1) (u_1+1)) (u_1+1) (u_2+1)) (max (u_2+1) (u_1+1))} (equiv.{u_2+1 u_1+1} β α)
               (@equiv.has_coe_to_fun.{u_2+1 u_1+1} β α)
               (@equiv.symm.{u_1+1 u_2+1} α β f))
            b))
      (@has_mem.mem.{u_2 u_2} β (option.{u_2} β) (@option.has_mem.{u_2} β) b
         (@function.comp.{u_1+1 u_2+1 u_2+1} α β (option.{u_2} β) (@option.some.{u_2} β)
            (@coe_fn.{(max 1 (max (u_1+1) (u_2+1)) (u_2+1) (u_1+1)) (max (u_1+1) (u_2+1))} (equiv.{u_1+1 u_2+1} α β)
               (@equiv.has_coe_to_fun.{u_1+1 u_2+1} α β)
               f)
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322  @[simp] lemma to_pequiv_refl : (equiv.refl α).to_pequiv = pequiv.refl α := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='equiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.to_pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pequiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 56, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 317, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 49, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π (α : Sort u_1), equiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, equiv.{u_1+1 u_1+1} α β → pequiv.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1), pequiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324  lemma to_pequiv_trans (f : α ≃ β) (g : β ≃ γ) : (f.trans g).to_pequiv =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.to_pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 317, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2 → Type (max (max u_1 u_2) u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_3 → Type (max (max u_2 u_3) u_3 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='equiv.{u_1+1 u_2+1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {γ : Type u_3}, equiv.{u_1+1 u_2+1} α β → equiv.{u_2+1 u_3+1} β γ → equiv.{u_1+1 u_3+1} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.{u_2+1 u_3+1} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_3}, equiv.{u_1+1 u_3+1} α β → pequiv.{u_1 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u_1 u_3)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325    f.to_pequiv.trans g.to_pequiv := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.to_pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.to_pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 317, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 317, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.{u_1+1 u_2+1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, equiv.{u_1+1 u_2+1} α β → pequiv.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {γ : Type u_3}, pequiv.{u_1 u_2} α β → pequiv.{u_2 u_3} β γ → pequiv.{u_1 u_3} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.{u_2+1 u_3+1} β γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, equiv.{u_2+1 u_3+1} α β → pequiv.{u_2 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type (max u_1 u_3)} {a : α}, @eq.{(max (u_1+1) (u_3+1))} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327  lemma to_pequiv_symm (f : α ≃ β) : f.symm.to_pequiv = f.to_pequiv.symm := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.to_pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.to_pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 317, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 317, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 54, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2 → Type (max (max u_1 u_2) u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='equiv.{u_1+1 u_2+1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, equiv.{u_1+1 u_2+1} α β → equiv.{u_2+1 u_1+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, equiv.{u_2+1 u_1+1} α β → pequiv.{u_2 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u_2 u_1)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.{u_1+1 u_2+1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, equiv.{u_1+1 u_2+1} α β → pequiv.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, pequiv.{u_1 u_2} α β → pequiv.{u_2 u_1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type (max u_2 u_1)} {a : α}, @eq.{(max (u_2+1) (u_1+1))} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329  lemma to_pequiv_apply (f : α ≃ β) (x : α) : f.to_pequiv x = some (f x) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.to_pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 317, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2 → Type (max (max u_1 u_2) u_2 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='equiv.{u_1+1 u_2+1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, equiv.{u_1+1 u_2+1} α β → pequiv.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.{u_1+1 u_2+1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331  end equiv</code></pre>
</body>